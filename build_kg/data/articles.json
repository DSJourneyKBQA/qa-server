[
    {
        "title": "Vue简介",
        "text": "什么是 Vue？\nVue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n\n下面是一个最基本的示例：\n\njs\ntemplate\n结果展示\n\n上面的示例展示了 Vue 的两个核心功能：\n\n声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n\n响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n你可能已经有了些疑问——先别急，在后续的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。\n\n预备知识\n\n文档接下来的内容会假设你对 HTML、CSS 和 JavaScript 已经基本熟悉。如果你对前端开发完全陌生，最好不要直接从一个框架开始进行入门学习——最好是掌握了基础知识再回到这里。你可以通过这篇 JavaScript 概述来检验你的 JavaScript 知识水平。如果之前有其他框架的经验会很有帮助，但也不是必须的。\n\n渐进式框架​\nVue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：\n\n无需构建步骤，渐进式增强静态的 HTML\n在任何页面中作为 Web Components 嵌入\n单页应用 (SPA)\n全栈 / 服务端渲染 (SSR)\nJamstack / 静态站点生成 (SSG)\n开发桌面端、移动端、WebGL，甚至是命令行终端中的界面\n如果你是初学者，可能会觉得这些概念有些复杂。别担心！理解教程和指南的内容只需要具备基础的 HTML 和 JavaScript 知识。即使你不是这些方面的专家，也能够跟得上。\n\n如果你是有经验的开发者，希望了解如何以最合适的方式在项目中引入 Vue，或者是对上述的这些概念感到好奇，我们在使用 Vue 的多种方式中讨论了有关它们的更多细节。\n\n无论再怎么灵活，Vue 的核心知识在所有这些用例中都是通用的。即使你现在只是一个初学者，随着你的不断成长，到未来有能力实现更复杂的项目时，这一路上获得的知识依然会适用。如果你已经是一个老手，你可以根据实际场景来选择使用 Vue 的最佳方式，在各种场景下都可以保持同样的开发效率。这就是为什么我们将 Vue 称为“渐进式框架”：它是一个可以与你共同成长、适应你不同需求的框架。\n\n单文件组件​\n在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\nvue\n单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于单文件组件的用法及用途。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。\n\nAPI 风格​\nVue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。\n\n选项式 API (Options API)​\n使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。\n\nvue\n在演练场中尝试一下\n\n组合式 API (Composition API)​\n通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 <script setup> 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<script setup> 中的导入和顶层变量/函数都能够在模板中直接使用。\n\n下面是使用了组合式 API 与 <script setup> 改造后和上面的模板完全一样的组件：\n\nvue\n在演练场中尝试一下\n\n该选哪一个？​\n两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。\n\n选项式 API 以“组件实例”的概念为中心 (即上述例子中的 this)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。\n\n组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。\n\n在组合式 API FAQ 章节中，你可以了解更多关于这两种 API 风格的对比以及组合式 API 所带来的潜在收益。\n\n如果你是使用 Vue 的新手，这里是我们的大致建议：\n\n在学习的过程中，推荐采用更易于自己理解的风格。再强调一下，大部分的核心概念在这两种风格之间都是通用的。熟悉了一种风格以后，你也能够很快地理解另一种风格。\n\n在生产项目中：\n\n当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。\n\n当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。\n\n在学习阶段，你不必只固守一种风格。在接下来的文档中我们会为你提供一系列两种风格的代码供你参考，你可以随时通过左上角的 API 风格偏好来做切换。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.18348603669276936
            },
            {
                "word": "javascript",
                "weight": 0.18348603669276936
            },
            {
                "word": "html",
                "weight": 0.18348603669276936
            },
            {
                "word": "css",
                "weight": 0.18348603669276936
            },
            {
                "word": "组件",
                "weight": 0.18348603669276936
            },
            {
                "word": "dom",
                "weight": 0.027523272178717778
            },
            {
                "word": "对象",
                "weight": 0.027523272178717778
            },
            {
                "word": "函数",
                "weight": 0.027523272178717778
            }
        ]
    },
    {
        "title": " HTML简介",
        "text": "什么是 HTML？\nHTML 是用来描述网页的一种语言。\n\nHTML 指的是超文本标记语言 (Hyper Text Markup Language)\nHTML 不是一种编程语言，而是一种标记语言 (markup language)\n标记语言是一套标记标签 (markup tag)\nHTML 使用标记标签来描述网页\nHTML 标签\nHTML 标记标签通常被称为 HTML 标签 (HTML tag)。\n\nHTML 标签是由尖括号包围的关键词，比如 <html>\nHTML 标签通常是成对出现的，比如 <b> 和 </b>\n标签对中的第一个标签是开始标签，第二个标签是结束标签\n开始和结束标签也被称为开放标签和闭合标签\nHTML 文档 = 网页\nHTML 文档描述网页\nHTML 文档包含 HTML 标签和纯文本\nHTML 文档也被称为网页\nWeb 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容：\n例子解释\n<html> 与 </html> 之间的文本描述网页\n<body> 与 </body> 之间的文本是可见的页面内容\n<h1> 与 </h1> 之间的文本被显示为标题\n<p> 与 </p> 之间的文本被显示为段落",
        "tags": [
            {
                "word": "标签",
                "weight": 0.5644539752811362
            },
            {
                "word": "html",
                "weight": 0.3051102569087223
            },
            {
                "word": "标题",
                "weight": 0.06521788390507068
            },
            {
                "word": "段落",
                "weight": 0.06521788390507068
            }
        ]
    },
    {
        "title": "JavaScript 简介",
        "text": "JavaScript 简介\n让我们来看看 JavaScript 有什么特别之处，我们可以用它实现什么，以及哪些其他技术可以与其搭配产生奇妙的效果。\n\n什么是 JavaScript？\nJavaScript 最初被创建的目的是“使网页更生动”。\n\n这种编程语言写出来的程序被称为 脚本。它们可以被直接写在网页的 HTML 中，在页面加载的时候自动执行。\n\n脚本被以纯文本的形式提供和执行。它们不需要特殊的准备或编译即可运行。\n\n这方面，JavaScript 和 Java 有很大的区别。\n\n为什么叫 JavaScript？\nJavaScript 在刚诞生的时候，它的名字叫 “LiveScript”。但是因为当时 Java 很流行，所以决定将一种新语言定位为 Java 的“弟弟”会有助于它的流行。\n\n随着 JavaScript 的发展，它已经成为了一门完全独立的语言，并且也拥有了自己的语言规范 ECMAScript。现在，它和 Java 之间没有任何关系。\n\n如今，JavaScript 不仅可以在浏览器中执行，也可以在服务端执行，甚至可以在任意搭载了 JavaScript 引擎 的设备中执行。\n\n浏览器中嵌入了 JavaScript 引擎，有时也称作“JavaScript 虚拟机”。\n\n不同的引擎有不同的“代号”，例如：\n\nV8 —— Chrome、Opera 和 Edge 中的 JavaScript 引擎。\nSpiderMonkey —— Firefox 中的 JavaScript 引擎。\n……还有其他一些代号，像 “Chakra” 用于 IE，“JavaScriptCore”、“Nitro” 和 “SquirrelFish” 用于 Safari，等等。\n上面这些术语很容易记住，因为它们经常出现在开发者的文章中。我们也会用到这些术语。例如，如果“V8 支持某个功能”，那么我们可以认为这个功能大概能在 Chrome、Opera 和 Edge 中正常运行。\n\n引擎是如何工作的？\n引擎很复杂，但是基本原理很简单。\n\n引擎（如果是浏览器，则引擎被嵌入在其中）读取（“解析”）脚本。\n然后，引擎将脚本转化（“编译”）为机器语言。\n然后，机器代码快速地执行。\n引擎会对流程中的每个阶段都进行优化。它甚至可以在编译的脚本运行时监视它，分析流经该脚本的数据，并根据获得的信息进一步优化机器代码。\n\n浏览器中的 JavaScript 能做什么？\n现代的 JavaScript 是一种“安全的”编程语言。它不提供对内存或 CPU 的底层访问，因为它最初是为浏览器创建的，不需要这些功能。\n\nJavaScript 的能力很大程度上取决于它运行的环境。例如，Node.js 支持允许 JavaScript 读取/写入任意文件，执行网络请求等的函数。\n\n浏览器中的 JavaScript 可以做与网页操作、用户交互和 Web 服务器相关的所有事情。\n\n例如，浏览器中的 JavaScript 可以做下面这些事：\n\n在网页中添加新的 HTML，修改网页已有内容和网页的样式。\n响应用户的行为，响应鼠标的点击，指针的移动，按键的按动。\n向远程服务器发送网络请求，下载和上传文件（所谓的 AJAX 和 COMET 技术）。\n获取或设置 cookie，向访问者提出问题或发送消息。\n记住客户端的数据（“本地存储”）。\n浏览器中的 JavaScript 不能做什么？\n为了用户的（信息）安全，在浏览器中的 JavaScript 的能力是受限的。目的是防止恶意网页获取用户私人信息或损害用户数据。\n\n此类限制的例子包括：\n\n网页中的 JavaScript 不能读、写、复制和执行硬盘上的任意文件。它没有直接访问操作系统的功能。\n\n现代浏览器允许 JavaScript 做一些文件相关的操作，但是这个操作是受到限制的。仅当用户做出特定的行为，JavaScript 才能操作这个文件。例如，用户把文件“拖放”到浏览器中，或者通过 <input> 标签选择了文件。\n\n有很多与相机/麦克风和其它设备进行交互的方式，但是这些都需要获得用户的明确许可。因此，启用了 JavaScript 的网页应该不会偷偷地启动网络摄像头观察你，并把你的信息发送到 美国国家安全局。\n\n不同的标签页/窗口之间通常互不了解。有时候，也会有一些联系，例如一个标签页通过 JavaScript 打开的另外一个标签页。但即使在这种情况下，如果两个标签页打开的不是同一个网站（域名、协议或者端口任一不相同的网站），它们都不能相互通信。\n\n这就是所谓的“同源策略”。为了解决“同源策略”问题，两个标签页必须 都 包含一些处理这个问题的特定的 JavaScript 代码，并均允许数据交换。本教程会讲到这部分相关的知识。\n\n这个限制也是为了用户的信息安全。例如，用户打开的 http://anysite.com 网页必须不能访问 http://gmail.com（另外一个标签页打开的网页）也不能从那里窃取信息。\n\nJavaScript 可以轻松地通过互联网与当前页面所在的服务器进行通信。但是从其他网站/域的服务器中接收数据的能力被削弱了。尽管可以，但是需要来自远程服务器的明确协议（在 HTTP header 中）。这也是为了用户的信息安全。如果在浏览器环境外（例如在服务器上）使用 JavaScript，则不存在此类限制。现代浏览器还允许安装可能会要求扩展权限的插件/扩展。\n\n是什么使得 JavaScript 与众不同？\n至少有 3 件事值得一提：\n\n与 HTML/CSS 完全集成。\n简单的事，简单地完成。\n被所有的主流浏览器支持，并且默认开启。\nJavaScript 是将这三件事结合在一起的唯一的浏览器技术。\n\n这就是为什么 JavaScript 与众不同。这也是为什么它是用于创建浏览器界面的使用最广泛的工具。\n\n此外，JavaScript 还可用于创建服务器和移动端应用程序等。\n\nJavaScript “上层”语言\n不同的人想要不同的功能。JavaScript 的语法也不能满足所有人的需求。\n\n这是正常的，因为每个人的项目和需求都不一样。\n\n因此，最近出现了许多新语言，这些语言在浏览器中执行之前，都会被 编译（转化）成 JavaScript。\n\n现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。\n\n此类语言的示例有：\n\nCoffeeScript 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，Ruby 开发者喜欢它。\nTypeScript 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。\nFlow 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\nDart 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。\nBrython 是一个 Python 到 JavaScript 的转译器，让我们可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。\nKotlin 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n这样的语言还有很多。当然，即使我们在使用此类编译语言，我们也需要了解 JavaScript。因为了解 JavaScript 才能让我们真正明白我们在做什么。如果在浏览器环境外（例如在服务器上）使用 JavaScript，则不存在此类限制。现代浏览器还允许安装可能会要求扩展权限的插件/扩展。\n\n是什么使得 JavaScript 与众不同？\n至少有 3 件事值得一提：\n\n与 HTML/CSS 完全集成。\n简单的事，简单地完成。\n被所有的主流浏览器支持，并且默认开启。\nJavaScript 是将这三件事结合在一起的唯一的浏览器技术。\n\n这就是为什么 JavaScript 与众不同。这也是为什么它是用于创建浏览器界面的使用最广泛的工具。\n\n此外，JavaScript 还可用于创建服务器和移动端应用程序等。\n\nJavaScript “上层”语言\n不同的人想要不同的功能。JavaScript 的语法也不能满足所有人的需求。\n\n这是正常的，因为每个人的项目和需求都不一样。\n\n因此，最近出现了许多新语言，这些语言在浏览器中执行之前，都会被 编译（转化）成 JavaScript。\n\n现代化的工具使得编译速度非常快且透明，实际上允许开发者使用另一种语言编写代码并会将其“自动转换”为 JavaScript。\n\n此类语言的示例有：\n\nCoffeeScript 是 JavaScript 的一种语法糖。它引入了更加简短的语法，使我们可以编写更清晰简洁的代码。通常，Ruby 开发者喜欢它。\nTypeScript 专注于添加“严格的数据类型”以简化开发，以更好地支持复杂系统的开发。由微软开发。\nFlow 也添加了数据类型，但是以一种不同的方式。由 Facebook 开发。\nDart 是一门独立的语言。它拥有自己的引擎，该引擎可以在非浏览器环境中运行（例如手机应用），它也可以被编译成 JavaScript。由 Google 开发。\nBrython 是一个 Python 到 JavaScript 的转译器，让我们可以在不使用 JavaScript 的情况下，以纯 Python 编写应用程序。\nKotlin 是一个现代、简洁且安全的编程语言，编写出的应用程序可以在浏览器和 Node 环境中运行。\n这样的语言还有很多。当然，即使我们在使用此类编译语言，我们也需要了解 JavaScript。因为了解 JavaScript 才能让我们真正明白我们在做什么。",
        "tags": [
            {
                "word": "javascript",
                "weight": 0.16666666666666663
            },
            {
                "word": "html",
                "weight": 0.16666666666666663
            },
            {
                "word": "函数",
                "weight": 0.16666666666666663
            },
            {
                "word": "ajax",
                "weight": 0.16666666666666663
            },
            {
                "word": "标签",
                "weight": 0.16666666666666663
            },
            {
                "word": "数据类型",
                "weight": 0.16666666666666663
            }
        ]
    },
    {
        "title": "Hello, world!",
        "text": "Hello, world!\n本教程的这一部分内容是关于 JavaScript 语言本身的。\n\n但是，我们需要一个工作环境来运行我们的脚本，由于本教程是在线的，所以浏览器是一个不错的选择。我们会尽可能少地使用浏览器特定的命令（比如 alert），所以如果你打算专注于另一个环境（比如 Node.js），你就不必多花时间来关心这些特定指令了。我们将在本教程的 下一部分 中专注于浏览器中的 JavaScript。\n\n首先，让我们看看如何将脚本添加到网页上。对于服务器端环境（如 Node.js），你只需要使用诸如 \"node my.js\" 的命令行来执行它。\n\n“script” 标签\n我们几乎可以使用 <script> 标签将 JavaScript 程序插入到 HTML 文档的任何位置。现代的标记（markup）\n<script> 标签有一些现在很少用到的特性（attribute），但是我们可以在老代码中找到它们：\n\ntype 特性：<script type=…>\n在老的 HTML4 标准中，要求 script 标签有 type 特性。通常是 type=\"text/javascript\"。这样的特性声明现在已经不再需要。而且，现代 HTML 标准已经完全改变了此特性的含义。现在，它可以用于 JavaScript 模块。但这是一个高阶话题，我们将在本教程的另一部分中探讨 JavaScript 模块。\n\nlanguage 特性：<script language=…>\n这个特性是为了显示脚本使用的语言。这个特性现在已经没有任何意义，因为语言默认就是 JavaScript。不再需要使用它了。外部脚本\n如果你有大量的 JavaScript 代码，我们可以将它放入一个单独的文件。\n\n脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中。外部脚本\n如果你有大量的 JavaScript 代码，我们可以将它放入一个单独的文件。\n\n脚本文件可以通过 src 特性（attribute）添加到 HTML 文件中。总结\n我们可以使用一个 <script> 标签将 JavaScript 代码添加到页面中。\ntype 和 language 特性（attribute）不是必需的。\n外部的脚本可以通过 <script src=\"path/to/script.js\"></script> 的方式插入。\n有关浏览器脚本以及它们和网页的关系，还有很多可学的。但是请记住，教程的这部分主要是针对 JavaScript 语言本身的，所以我们不该被浏览器特定的实现分散自己的注意力。我们将使用浏览器作为运行 JavaScript 的一种方式，这种方式非常便于我们在线阅读，但这只是很多种方式中的一种。\n\n任务\n显示一个提示语\n重要程度: 5\n创建一个页面，然后显示一个消息 “I’m JavaScript!”。\n\n在沙箱中或者在你的硬盘上做这件事都无所谓，只要确保它能运行起来。\n\n在新窗口中演示使用外部的脚本显示一个提示语\n重要程度: 5\n打开前一个任务 显示一个提示语 的答案。将脚本的内容提取到一个外部的 alert.js 文件中，放置在相同的文件夹中。\n\n打开页面，确保它能够工作。",
        "tags": [
            {
                "word": "javascript",
                "weight": 0.46511615458001815
            },
            {
                "word": "标签",
                "weight": 0.46511615458001815
            },
            {
                "word": "html",
                "weight": 0.06976769083996354
            }
        ]
    },
    {
        "title": "循环：while 和 for",
        "text": "循环：while 和 for\n我们经常需要重复执行一些操作。\n\n例如，我们需要将列表中的商品逐个输出，或者运行相同的代码将数字 1 到 10 逐个输出。\n\n循环 是一种重复运行同一代码的方法。\n\nfor…of 和 for…in 循环\n给进阶读者的一个小提示。\n\n本文仅涵盖了基础的循环：while，do..while 和 for(..; ..; ..)。\n\n如果你阅读本文是为了寻找其他类型的循环，那么：\n\n用于遍历对象属性的 for..in 循环请见：for…in。\n用于遍历数组和可迭代对象的循环分别请见：for…of 和 iterables。\n否则，请继续阅读。\n\nwhile 循环\nwhile 循环会在条件为 true 时重复执行代码。\n\n例如，下面的代码会重复输出 i 的值，直到 i 等于 3：\n\nlet i = 0;\nwhile (i < 3) { // 当 i == 3 时停止\n  alert( i );\n  i++;\n}\n\n在这个例子中，循环会输出 0，然后 1，然后 2。\n\n在每次循环中，它都会检查条件 i < 3。如果条件为 true，它就会运行代码块，然后再次检查条件，如果条件仍然为 true，就再次运行代码块，然后再次检查条件……\n\n如果条件为 false，循环就会停止。\n\ndo..while 循环\ndo..while 循环也会重复执行代码，但是它会在条件为 false 时停止。\n\n例如，下面的代码会重复输出 i 的值，直到 i 等于 3：\n\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n\n在这个例子中，循环会输出 0，然后 1，然后 2。\n\n在每次循环中，它都会运行代码块，然后检查条件 i < 3。如果条件为 true，它就会再次运行代码块，然后再次检查条件，如果条件仍然为 true，就再次运行代码块，然后再次检查条件……\n\n如果条件为 false，循环就会停止。\n\nfor 循环\nfor 循环是最常见的循环。\n\n它看起来像这样：\n\nfor (begin; condition; step) {\n  // ... 循环体 ...\n}\n\nbegin：在循环开始前执行。\ncondition：在每次循环开始前检",
        "tags": [
            {
                "word": "对象",
                "weight": 0.5
            },
            {
                "word": "数组",
                "weight": 0.5
            }
        ]
    },
    {
        "title": "HTML是什么？HTML简介",
        "text": "HTML是什么？HTML简介\nHTML 英文全称是 Hyper Text Markup Language，中文译为“超文本标记语言”，专门用来设计和编辑网页。\n\n使用 HTML 编写的文件称为“HTML 文档”，一般后缀为.html（也可以使用.htm，不过比较少见）。HTML 文档是一种纯文本文件，您可以使用 Windows 记事本、Linux Vim、Notepad++、Sublime Text、VS Code 等文本编辑来打开或者创建。\n\n每个网页都是一个 HTML 文档，使用浏览器访问一个链接（URL），实际上就是下载、解析和显示 HTML 文档的过程。将众多 HTML 文档放在一个文件夹中，然后提供对外访问权限，就构成了一个网站，这一点已经在前一节中提及。\n\nHTML 到底是什么？\n首先，HTML 不是编程语言，没有逻辑处理能力，没有计算能力，不能动态地生成内容，而只能静态地展示网页信息。\n\n我们从 HTML 中文全称来分析一下它的本质：\n\n超文本\n也即超越纯文本，这意味着 HTML 文档不仅能包含文本（文字），还能包含图片、音视频、表格、列表、链接、按钮、输入框等高级内容。\n超链接是互联网的纽带，它能将众多网页连接起来，让它们交织在一起，形成一张“网”。没有超链接，就没有互联网。\n\n标记语言\nHTML 是一种计算机语言，但它不能编程，只能用来标记网页中的内容。HTML 通过不同的标签来标记不同的内容、格式、布局等，\n总结\n\nHTML 是一种用来开发网页的计算机语言，它通过标签（标记式指令）将文本、音视频、图片、表格、按钮、输入框等内容显示出来。也就是说，HTML 是用来给网页内容进行排版和布局的。\n\nHTML 版本\n\n自 HTML 诞生以来，经过不断的发展，市面上出现了许多 HTML 版本，有关 HTML 版本的简要介绍如下所示：\n\nHTML版本 版本说明\nHTML 1.0 HTML 的第一个版本，发布于 1991 年。\n\nHTML 2.0 HTML 的第二个版本，发布于 1995 年，该版本中增加了表单元素以及文件上传等功能。\n\nHTML 3.2 HTML 的第三个版本由 W3C 于 1997 年初发布，该版本增加了创建表格以及表单的功能。\n\nHTML 4.01 HTML 4.01 于 1999 年 12 月发布，该版本增加了对样式表（CSS）的支持。HTML 4.01 是一个非常稳定的版本，是当前的官方标准。\nHTML 5 HTML5 的初稿于 2008 年 1 月发布，是公认的下一代 Web 语言，极大地提升了 Web 在富媒体、富内容和富应用等方面的能力，被喻为终将改变移动互联网的重要推手。\n\nHTML 4 和 HTML 5（简称 H5）是两个最重要版本，HTML 4 适应了 PC 互联网时代，HTML 5 适应了移动互联网时代。\n\nHTML 5 在 HTML 4 的基础上增加了很多语义化的标签，功能更加强大，除了较低版本的 IE 浏览器，几乎所有其它浏览器都能很好地支持 HTML 5。如果您的用户很少使用 IE 浏览器，那么请放心地使用 HTML 5。\n\nHTML标签\n\n如上所述，HTML 是一种标记语言，使用各种标签来格式化内容，标签的特点如下所示：\n\nHTML 标签由尖括号包围的关键词构成，比如 ；\n除了少数标签外，大多数 HTML 标签都是成对出现的，比如 和 ；\n成对出现的标签中，第一个标签称为开始标签，第二个标签称为结束标签（闭合标签）。\n\nHTML 中的不同标签具有不同的含义，学习 HTML 其实就是学习各个标签的含义，根据实际场景的需要，选择合适的标签，从而制作出精美的网页。\nHTML文档结构\n\nHTML 页面的基本结构如下所示，其中包含了各种创建网页所需的标签（例如 doctype、html、head、title 和 body 等）。\n由于 HTML 文档属于文本文件，所以我们可以使用任何文本编辑器来创建和修改 HTML 文件，对于初学者来说最好使用系统自带的文本编辑器，例如 Windows 记事本、Linux Vim 和 Mac OS TextEdit，当有了一定的基础之后再选用专业的文本编辑器，例如 Notepad++、Sublime Text、VS Code 等。\n\n另外，您必须将 HTML 文档保存为.html或者.htm格式才可以直接在浏览器中打开并浏览其中的内容。例如上面的示例代码，将其保存在一个名为 index.html 的文件中，双击即可在浏览器中看到运行结果，如下图所示：",
        "tags": [
            {
                "word": "html",
                "weight": 0.23255791984709095
            },
            {
                "word": "图片",
                "weight": 0.23255791984709095
            },
            {
                "word": "表格",
                "weight": 0.23255791984709095
            },
            {
                "word": "标签",
                "weight": 0.23255791984709095
            },
            {
                "word": "链接",
                "weight": 0.03488416030581799
            },
            {
                "word": "css",
                "weight": 0.03488416030581799
            }
        ]
    },
    {
        "title": "html中的if语句怎么写,HTML如何使用if语句？",
        "text": "1，首先说明html的基本结构\n\n—— <html>内容</html> html文档的文档标记，也称为html开始标记 这对标记分别位于网页的最前端和最后端，表示开始和结束\n\n——<head>内容</head> html的文件头标记，也称为html头信息开始标记 用来包含文件的基本信息，比如网页的标题、关键字、 在<head></head>内可以放<title></title>,<meta></meta>,<style></style>等标记 注意：在<head></head>标记的内容不会在浏览器中显示\n\n——<title>内容</title> html文件标题标记，是网页的主题，显示在浏览器左上边 <title></title>放置于<head></head>中，标记中不能含有其他内容\n\n——<body>内容</body> <body>...</body>是网页的主体部分，在此标记之间可以包含<p></p> <h1></h1> <br> <hr>等标记，正是这些标记组成了我们常见的网页。body标记的常见属性 bgcolor\n\n设置背景颜色 <body bgcolor=\"red\"></body> text\n\n设置文本颜色 <body text=\"green\"></body> link\n\n设置链接颜色 <body link=\"blue\"></body> vlink\n\n已经访问了的链接颜色 <body vlink=\"yellow\"></body> alink\n\n正在被点击的链接颜色 <body alink=\"red\"></body>\n\n2，html元素节点中不能使用if，如果写了if也只是被当成字符串。\n\n3，在html页面中使用if只能写在script中。\n\n4，简单来说就是\n\nif (条件)\n{\n只有当条件为 true 时执行的代码\n}\n\n例如：\nif(age >18){\nalert(\"您已经成年了\");\n\n}",
        "tags": [
            {
                "word": "html",
                "weight": 0.3333333333333333
            },
            {
                "word": "标题",
                "weight": 0.3333333333333333
            },
            {
                "word": "链接",
                "weight": 0.3333333333333333
            }
        ]
    },
    {
        "title": "HTML 之 ＜a＞标签（超链接标签）",
        "text": "a标签\n作用：实现页面之间的跳转\n注意：\n\na标签可以让文字进行跳转，图片也可以\n一个a标签必须要有一个href属性\n指定url地址时一定加上http：//或者https；//\nTarget属性\nSelf 用于当前页面跳转，也就是不建立新的页面，默认是self\nBlank 用于在新的选项卡中跳转\nTitle属性\n同img标签中一样，实现悬停显示弹窗效果\n\n假链接\n不知道目标链接地址使用。直接在href中写#，点击之后会回到页面顶部",
        "tags": [
            {
                "word": "html",
                "weight": 0.2
            },
            {
                "word": "标签",
                "weight": 0.2
            },
            {
                "word": "图片",
                "weight": 0.2
            },
            {
                "word": "页面跳转",
                "weight": 0.2
            },
            {
                "word": "链接",
                "weight": 0.2
            }
        ]
    },
    {
        "title": "HTML中 ＜img＞标签的用法",
        "text": "<img> 语法  \n        在HTML网页中经常需要插入图片，使页面更加美观，表达更加清晰准确。插入图片，在\nHTML中是由<img>标签定义的，通过它可以导入需要显示的图片。<img>是单标签，它只包含属性，没有结束标签，要记得在“>”结束符号前加\"/\"自封口。\n\n从技术上讲，图片并不是插入到网页中的，而是链接到网页中的，<img>标签的作用是为被引用的图片创建占位符。<img>标签在网页中很常用，比如，引入Logo 图片、按钮背景图工具图等。<img>标签的语法是：\n\n        <img src=\"被引用图片的地址\" alt=\"图片的代替文本\">\n\n<img>标签包含两个常用的属性 src 和 alt.\nsrc 属性用来指定需要嵌入到网页中的图片的地址，可以使用相对地址，也可以使用绝对地址，甚至可以是互联网上的一个图片路径。但是一定要保证路径的正确，网页运行时，浏览器会根据这个地址找到图片文件并显示出来，如果地址不正确，图片就无法显示。\n\n        alt 属性用来规定图片的替代文本，当图片不显示时，将显示该属性内容。搜索引擎会读取该属性值内容作为图片表达的意思，所以搜索引擎优化中需要注意该属性，\n\n        src 属性和 alt 属性是<img> 标签必要属性。虽然，alt 属性缺失也不会出错，但建议设置该属性。如果不设置，搜索引擎不能获取图片表达的信息。如果图片不能正确显示那么会出现空白，用户也无法获得有效信息。除了 src 和 alt 属性，<img> 标签还有其他属性，\n图片插入时会按图片原始尺寸显示，想要修改图片的大小可以通过 width 和 height 属性来设置，width 和 height 属性值可以任意设置，默认单位是像素（px）。如果希望图片成比例缩放的话，可以只设置width 或只设置 height ，那样另一个值会成比例缩放。图片是一个二维图形，默认情况下和同一区域的文字是底部对齐的，这样会产生很大的空白区域。可以设置图片的浮动属性，使文字可以在图片一侧显示。浮动属性是CSS样式中的一个属性，可以通过style 属性设置，设置浮动效果后文字会和图片顶端对齐，自动换行则出现在图片的一侧。如果图片的 style 属性设置为 float：left；那么图片靠右侧浮动，文字出现在图片右侧；如果设置为 float：right ；那么图片靠右浮动，出现在父元素的右侧。\n\n        图片也可以作为超链接对象，只要通过<a> 标签包含<img> 标签，图片就变成超链接对象。作为超链接的图片和普通图片的用法于显示效果一样，只是光标移到图片上会变成手形。也可以通过 border 属性设置图片的边框。\n\n",
        "tags": [
            {
                "word": "标签",
                "weight": 0.38461394503699525
            },
            {
                "word": "图片",
                "weight": 0.38461394503699525
            },
            {
                "word": "html",
                "weight": 0.05769302748150241
            },
            {
                "word": "链接",
                "weight": 0.05769302748150241
            },
            {
                "word": "css",
                "weight": 0.05769302748150241
            },
            {
                "word": "对象",
                "weight": 0.05769302748150241
            }
        ]
    },
    {
        "title": "HTML系列之段落标签p",
        "text": "1、什么是段落标签了\n可以把 HTML 文档分割为若干段落的标签。\n\n该标签通常表现为一整块与相邻文本分离的文本，或以垂直的空白或以首行缩进。\n\n在网页中要把文档有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是HTML文档中的最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。\n5、总结\n<p> 是块级元素；\n起始标签是必需的，结束标签在以下情形下可以省略。<p> 标签后紧跟 <address>，<article>，<aside>，<blockquote>，<div>，<dl>，<fieldset>，<footer>，<form>，<h1>系列，<header>，<hr>，<menu>，<nav>，<ol>，<pre>，<section>，<table>，<ul>，或另一个 <p> 标签；或者父标签中没有其他内容了，而且父元素不是 <a> 元素；\n使用 CSS margin 属性去改变段落之间的空隙，不要在段落之间插入空的短段落元素或者 <br> 标签；",
        "tags": [
            {
                "word": "标签",
                "weight": 0.3467770426357535
            },
            {
                "word": "段落",
                "weight": 0.3319287850287934
            },
            {
                "word": "html",
                "weight": 0.19085938971221705
            },
            {
                "word": "块级元素",
                "weight": 0.043478260874412075
            },
            {
                "word": "div",
                "weight": 0.043478260874412075
            },
            {
                "word": "css",
                "weight": 0.043478260874412075
            }
        ]
    },
    {
        "title": "HTML基础——br标签",
        "text": "作用\n在HTML中实现换行\n\n格式\n< br >\n\n注意点\n多个br标签可以连续使用，使用多少个br标签就会换多少行；\n由于HTML的作用就是用来给文本添加语义，而br标签的语义是不另起段落换行，而在企业开发中一般情况下需要换行都是因为需要另起一段，所以在企业开发中很少使用br标签；\n如果是没有描述完的，但需要换行就用< br >;如果这一段已经描述完了，需要换行，就用< p >",
        "tags": [
            {
                "word": "html",
                "weight": 0.3333333333333333
            },
            {
                "word": "标签",
                "weight": 0.3333333333333333
            },
            {
                "word": "段落",
                "weight": 0.3333333333333333
            }
        ]
    },
    {
        "title": "HTML表格（HTML 表格的使用，收藏这一篇就够了）",
        "text": "HTML 表格\n文章目录\nHTML 表格\n1. 表格的定义\n2. 表格的标签\n3. 单元格边框(border)\n4. 合并单元格\n4.1 合并行单元格(colspan)\n4.2 合并列单元格(rowspan)\n5. 表格格式设置\n5.1 单元格的对齐（align）（居中，左对齐，右对齐）\n5.2. 背景色&图片（bgcolor & background）\n5.2.1 单元格背景色&图片\n5.2.2 表格背景色&图片\n5.3 单元格的边距（cellpadding）\n5.4 单元格间的距离(cellspacing)\n5.5 显示部分边框（frame & rules）\n1. 表格的定义\n<table> 标签定义 HTML 表格。简单的 HTML 表格由 table 元素以及一个或多个 <tr>、<th> 或 <td> 元素组成表格结构；其中： <tr> 元素定义表格行，<th> 元素定义表头，<td> 元素定义表格单元。\n为了让表格更美观，我们会用到：border，colspan，rowspan，align，bgcolor 等来美化表格，具体在本文都有讲解；\n\n2. 表格的标签\n在HTML定义表格的时候，有以下标签供我们使用\n\nNO\n\n表格标签\n\n用处\n\n1\n\n<table>\n\n定义表格，生成的表格在一对<table></table>中；\n\n2\n\n<caption>\n\n定义表格标题，当表格需要标题时，使用<caption>表格标题</caption>\n\n3\n\n<thead>\n\n定义表格的页眉\n\n4\n\n<tbody>\n\n定义表格的主体\n\n5\n\n<tfoot>\n\n定义表格的页脚\n\n6\n\n<th>\n\n定义表格的表头，一般是表头中的内容会被加黑；\n\n7\n\n<tr>\n\n定义表格的行\n\n8\n\n<td>\n\n定义表格单元格\n\n9\n\n<col>\n\n定义用于表格列的属性\n\n10\n\n<colgroup>\n\n定义表格列的组\n\n3. 单元格边框(border)\n表格边框：在使用<table border=\"1\"></table> 的方式来定义，其中：数字表示边框的宽度，单位为像素\n5.5 显示部分边框（frame & rules）\n可以在<table></table>标签内，增加 frame 键值对，控制表格外边框；键值对对应关系如下：\nframe 键值\n\n效果\n\nvoid\n\n不显示外侧边框\n\nabove\n\n显示上部的外侧边框\n\nbelow\n\n显示下部的外侧边框\n\nhsides\n\n显示上部和下部的外侧边框\n\nvsides\n\n显示左边和右边的外侧边框\n\nlhs\n\n显示左边的外侧边框\n\nrhs\n\n显示右边的外侧边框\n\nbox\n\n在所有四个边上显示外侧边框\n\nborder\n\n在所有四个边上显示外侧边框\n\n可以在<table></table>标签内，增加 rules 键值对，控制表格外边框；键值对对应关系如下：\nframe 键值\n\n效果\n\nnone\n\n没有线条\n\ngroups\n\n位于行组和列组之间的线条\n\nrows\n\n位于行之间的线条\n\ncols\n\n位于列之间的线条\n\nall\n\n位于行和列之间的线条",
        "tags": [
            {
                "word": "表格",
                "weight": 0.46239117916465644
            },
            {
                "word": "html",
                "weight": 0.16715474750736348
            },
            {
                "word": "标签",
                "weight": 0.16715474750736348
            },
            {
                "word": "标题",
                "weight": 0.16715474750736348
            },
            {
                "word": "图片",
                "weight": 0.03614457831325302
            }
        ]
    },
    {
        "title": "用CSS设置颜色、背景和图像效果",
        "text": "📜个人简介\n\n⭐️个人主页：微风洋洋🙋‍♂️\n🍑博客领域：编程基础💡,后端💡,大数据,信息安全\n🍅写作风格：干货,干货,还是tmd的干货\n🌸精选专栏：【JavaScript】【HTML+CSS】【Java学习笔记】【Java必刷题】\n🚀支持洋洋：点赞👍、收藏⭐、留言💬\n\n好久不见，甚是想念！\n大家好！\n\n我是微风洋洋 今天这篇文章就是来和大家简单聊聊用CSS设置颜色、背景、图像效果，希望大家读完有所收获，那我辛苦码字也就值了。如果你觉得对你有一丢丢启发的话，不妨 点赞、收藏、关注支持一下，你的支持将是我继续创作的最大动力。下一篇将介绍重头戏——CSS盒子模型和网页布局，到时不见不散~~~\n文章目录\n一、用CSS设置颜色与背景\n颜色设置\n背景设置\n圆角边框和图像边框\n二、用CSS设置图像效果\n1.为图片添加边框\n2.图片缩放\n3.图文混排\n三、总结\n一、用CSS设置颜色与背景\n颜色设置\ncolor属性是用于控制HTML元素内文本的颜色，取值可以使用下面的任意一种方式。\n\n颜色名：直接使用颜色的英文名称作为属性值，例如，blue表示蓝色。\n#rrggbb：用一个6位的十六进制数表示颜色，例如，#0000FF表示蓝色。\n#rgb：是#rrggbb的一种简写方式，例如，#0000FF可以表示为#00F，#00FFDD表示为#0FD。\nrgb（rrr,ggg,bbb）：使用十进制数表示颜色的红、绿、蓝分量，其中，rrr、ggg、bbb都是0～255的十进制整数。例如，rgb（0,0,0）代表黑色。\nrgb（rrr%,ggg%,bbb%）：使用百分比表示颜色的红、绿、蓝分量，例如，rgb（50%，50%，50%）表示rgb（128，128，128）。\n当然看个人喜好了，简单点就直接输英文名也没什么大问题\n背景设置\n1．background-color属性\n\nbackground-color属性用于设置HTML元素的背景颜色。\n\n\n2．background-image属性\n\nbackground-image属性用于设置HTML元素的背景图像，取值为url（imageurl）或none。\n\n\n3．background-attachment属性\n\nbackground-attachment属性控制背景图像是否随内容一起滚动，取值为scroll或fixed。\n\n\n4．background-position属性\n\nbackground-position属性指定了背景图像相对于关联区域左上角的位置。\n\n\n5．background-repeat属性\n\nbackground-repeat属性用来表示背景图像是否重复显示，取值可以是repeat/repeat-x/repeat-y/ no-repeat。\n\n\n6．background属性\n\nbackground属性与font属性类似，它也是一个组合属性，可用于同时设置background-color、background-image、background-attachment、background-position和background-repeat等背景属性。\n圆角边框和图像边框\n1．圆角边框\n\n使用border-radius属性可以设计各种类型的圆角边框。可以直接给border-radius属性赋一组值来定义圆角。\n\n如果直接给border-radius属性赋4个值，这4个值按照top-left、top-right、bottom-left、bottom-right的顺序来设置。\n\n• 如果只设置1个值，则表示4个圆角相同。\n\n• 如果bottom-left值省略，其圆角效果与top-right相同。\n\n• 如果bottom-right值省略，其圆角效果与top-left相同。\n\n• 如果top-right值省略，其圆角效果与top-left相同。\n二、用CSS设置图像效果\n使用标记的border属性可以为图片添加边框，属性值为边框的粗细，以像素为单位，从而控制边框的效果。当设置属性值为0时，则显示为没有边框。下面是为图片添加边框的代码。\n\n<img src=\"img1.jpg\" border=\"2\" />\n\n<img src=\"img2.jpg\" border=\"0\" />\n\n\n1.为图片添加边框\n边框的不同属性\n\nborder-width（粗细）：设置边框的粗细，可以使用各种CSS中的长度单位，通常用的是像素。\nborder-color（颜色）：定义边框的颜色，可以使用各种合法的颜色定义方式。\nborder-style（线型）：选择一些预先定义好的线型，如虚线、实线或点划线等。\n2.图片缩放\n1．使用标记的width和height属性\n通过标记的描述属性width和height可以设置图片大小。\n\n2．使用CSS3中max-width属性和max-height属性\n\nmax-width和max-height分别用来设置图片宽度最大值和高度最大值。\n\n2.图片缩放\n1．使用标记的width和height属性\n通过标记的描述属性width和height可以设置图片大小。\n\n2．使用CSS3中max-width属性和max-height属性\n\nmax-width和max-height分别用来设置图片宽度最大值和高度最大值。\n\n2.图片缩放\n1．使用标记的width和height属性\n通过标记的描述属性width和height可以设置图片大小。\n\n2．使用CSS3中max-width属性和max-height属性\n\nmax-width和max-height分别用来设置图片宽度最大值和高度最大值。\n\n",
        "tags": [
            {
                "word": "css",
                "weight": 0.25
            },
            {
                "word": "javascript",
                "weight": 0.25
            },
            {
                "word": "html",
                "weight": 0.25
            },
            {
                "word": "图片",
                "weight": 0.25
            }
        ]
    },
    {
        "title": "前端知识——css之flex布局",
        "text": "1.基本概念\nflex布局是一种布局模型，经常被称之为flexbox，使用flex布局之后，他会给子元素提供强大空间分配和对齐能力。\n            \n在没有使用flex布局之前，常用布局有：流式布局，浮动布局，定位布局等等。缺陷是子元素需要自己控制自己在父元素中的位置，还要注意父元素高度坍塌。\n            \nflex的优点就是避免不灵活的布局形式，创建更多种布局模式供你选择，解决了子元素的对齐和分布与 响应式等问题。缺点是只能依靠自身的布局模式，稍有变化则无法改变。 \n\n2.flex的指定\n （1）display属性\n            \n给任意元素声明display：flex或者声明display：inline-flex（保持内联特性，用的很少）都会创建弹性布局。 果你使用flex，那么你先要知道布局结构\n给外层元素定义flex，把外层元素当“容器”元素，来控制其内部的子项元素“项目”的排列方式\n                \n（2）注意事项\n            \n\n依靠容器元素的属性，控制的是项目的排列方式，也就是说控制的不是自身，而是子元素            \n设置为flex布局以后，子元素的float，clear都失效了，换言之子元素不用浮动了，父元素也不用清除浮动了         \n设置了flex的元素，子元素会“块状化”。换言之，父元素使用了display：flex其子元素都会变成块级元素。 \n3.主轴的排列方向 \n（1）行模式和列模式\n                \n\n行模式就是子元素（项目）在容器中以行（x轴）方向排列的模式 \n列模式就是子元素（项目）在容器中以列（y轴）方向 4.主轴排序\n主轴方向可以取四个值，注意这四个值都要在容器中写的5.换行模式\nflex-wrap 属性来控制flex子项（项目）单行显示换行和不换行，默认情况不换行，即使容器无法承受所有项目，他们会按照等比例压缩，强制在主轴方向显示。6.主轴上的对齐方向\njustify-content  定义了项目在主轴方向上的对齐方式，需要注意的是，要区别行模式和列模式，当然主要可以以行模式为例。7.交叉轴对齐方式\n align-items指的是交叉轴的对齐方式，如果没有指定交叉轴对齐方式默认是 normal 项目无高度，默认撑满容器高度。8.多轴线对齐 \nalign-content属性设置浏览器如何沿着弹性布局的横纵项，多轴线分布的空间方式。9.多轴线对齐 \n（1）项目的排序顺序\norder项目在布局时的顺序，数值越小,，排列越靠前，默认值为0，可以是负数，数值没有单位。\n（2）项目的增长规则：flex-grow规定了项目在flex容器中分配剩余空间的比例。负值无效，默认值0，数值不需要单位。\n\nflex给某项目，前提容器中主轴方向是有剩余空间的\n项目本身是有自己的尺寸的，不放大时使用自身的长度尺寸。如：宽度设置了增长规则之后，原本尺寸失效了，使用增长规则的系数\n剩余空间的比重分配，是所有项目的flex-grow系数相加，之后再按比例分配3）项目的收缩规则\n\n flex-shrink指定了flex项目的收缩规则，默认值1，不允许负值，没有任何单位\n收缩前提，容器中无剩余空间，项目才会被压缩            \n\n设置了收缩比例后，元迟勋会在压缩时失效，而使用收缩系数                  \n收缩数值越大，压缩比例就越大             \n压缩的分配比重，缩小的尺寸是所有项目缩小系数之和，再按比例分配   \n强制不缩小，flex-shrink：0；（4）项目的初始化规则\nflex-basis指定了flex项目元素在主轴方向上的初始化大小（尺寸），不允许负值，默认auto，如果指定该属性，则原本尺寸，将失效。（5）项目的flex简写❤\n\n flex属性指的是，增长规则，缩小规则，初始化尺寸的集合写法。           \n\n默认flex：0 1 auto；                  \nflex：1； 指增长规则系数                      \nflex：0 0 200px； 指新项目在容器中不放大，也不缩小，初始化尺寸200px\n【总结】         \n用于容器的属性\ndisplay：flex 指定flex布局                       \n\nflex-direction 主轴的排序（主轴方向），默认值row                        \n\nflex-warp：nowarp 项目在容器中是否换行显示，常用之warp                        \n\njustify-content 主轴的对齐方式                        \n\nalign-items交叉轴的对齐方式（一般用于单轴线）                        \n\nalign-content多轴线对齐方式\n\n用于项目的属性\norder：0项目的排序                       \n\nflex-grow：0放大规则，默认0，不放大                      \n\nflex-shrink：1 收缩规则，默认1，缩小；0，不缩小。                        \n\nflex-basis：200px 指定主轴长度尺寸，不允许负值，默认值auto，优先级比主轴的尺寸高    \n\nflex集合写法，放大，缩小，初始尺寸，默认0  1  auto。flex：1指放大，flex：0  0不放大不缩小    ",
        "tags": [
            {
                "word": "css",
                "weight": 0.3333333333333333
            },
            {
                "word": "块级元素",
                "weight": 0.3333333333333333
            },
            {
                "word": "优先级",
                "weight": 0.3333333333333333
            }
        ]
    },
    {
        "title": "CSS学习21：fixed（固定定位）",
        "text": "固定定位是元素固定于浏览器可视区的位置。（认死理型） 主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。\n\n语法：\n\n 选择器 { \n    position: fixed; \n }\n固定定位的特点：（务必记住）：\n\n1.以浏览器的可视窗口为参照点移动元素。\n\n跟父元素没有任何关系\n\n不随滚动条滚动。\n\n2.固定定位不在占有原先的位置。\n\n固定定位也是脱标的，其实固定定位也可以看做是一种特殊的绝对定位。（认死理型）\n\n完全脱标—— 完全不占位置；\n\n只认浏览器的可视窗口 —— 浏览器可视窗口 + 边偏移属性 来设置元素的位置；\n\n跟父元素没有任何关系；单独使用的\n\n不随滚动条滚动。\n\n",
        "tags": [
            {
                "word": "css",
                "weight": 1.0
            }
        ]
    },
    {
        "title": "Vue简介",
        "text": "什么是 Vue？​\nVue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n\n下面是一个最基本的示例：\n\njs\ntemplate\n结果展示\n\n上面的示例展示了 Vue 的两个核心功能：\n\n声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。\n\n响应性：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新 DOM。\n\n你可能已经有了些疑问——先别急，在后续的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。\n\n预备知识\n\n文档接下来的内容会假设你对 HTML、CSS 和 JavaScript 已经基本熟悉。如果你对前端开发完全陌生，最好不要直接从一个框架开始进行入门学习——最好是掌握了基础知识再回到这里。你可以通过这篇 JavaScript 概述来检验你的 JavaScript 知识水平。如果之前有其他框架的经验会很有帮助，但也不是必须的。\n\n渐进式框架​\nVue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：\n\n无需构建步骤，渐进式增强静态的 HTML\n在任何页面中作为 Web Components 嵌入\n单页应用 (SPA)\n全栈 / 服务端渲染 (SSR)\nJamstack / 静态站点生成 (SSG)\n开发桌面端、移动端、WebGL，甚至是命令行终端中的界面\n如果你是初学者，可能会觉得这些概念有些复杂。别担心！理解教程和指南的内容只需要具备基础的 HTML 和 JavaScript 知识。即使你不是这些方面的专家，也能够跟得上。\n\n如果你是有经验的开发者，希望了解如何以最合适的方式在项目中引入 Vue，或者是对上述的这些概念感到好奇，我们在使用 Vue 的多种方式中讨论了有关它们的更多细节。\n\n无论再怎么灵活，Vue 的核心知识在所有这些用例中都是通用的。即使你现在只是一个初学者，随着你的不断成长，到未来有能力实现更复杂的项目时，这一路上获得的知识依然会适用。如果你已经是一个老手，你可以根据实际场景来选择使用 Vue 的最佳方式，在各种场景下都可以保持同样的开发效率。这就是为什么我们将 Vue 称为“渐进式框架”：它是一个可以与你共同成长、适应你不同需求的框架。\n\n单文件组件​\n在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\nvue\n单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于单文件组件的用法及用途。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。\n\nAPI 风格​\nVue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。\n\n选项式 API (Options API)​\n使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。\n\nvue\n在演练场中尝试一下\n\n组合式 API (Composition API)​\n通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 <script setup> 搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，<script setup> 中的导入和顶层变量/函数都能够在模板中直接使用。\n\n下面是使用了组合式 API 与 <script setup> 改造后和上面的模板完全一样的组件：\n\nvue\n在演练场中尝试一下\n\n该选哪一个？​\n两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。\n\n选项式 API 以“组件实例”的概念为中心 (即上述例子中的 this)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。\n\n组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。\n\n在组合式 API FAQ 章节中，你可以了解更多关于这两种 API 风格的对比以及组合式 API 所带来的潜在收益。\n\n如果你是使用 Vue 的新手，这里是我们的大致建议：\n\n在学习的过程中，推荐采用更易于自己理解的风格。再强调一下，大部分的核心概念在这两种风格之间都是通用的。熟悉了一种风格以后，你也能够很快地理解另一种风格。\n\n在生产项目中：\n\n当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。\n\n当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。\n\n在学习阶段，你不必只固守一种风格。在接下来的文档中我们会为你提供一系列两种风格的代码供你参考，你可以随时通过左上角的 API 风格偏好来做切换。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.18348603669276936
            },
            {
                "word": "javascript",
                "weight": 0.18348603669276936
            },
            {
                "word": "html",
                "weight": 0.18348603669276936
            },
            {
                "word": "css",
                "weight": 0.18348603669276936
            },
            {
                "word": "组件",
                "weight": 0.18348603669276936
            },
            {
                "word": "dom",
                "weight": 0.027523272178717778
            },
            {
                "word": "对象",
                "weight": 0.027523272178717778
            },
            {
                "word": "函数",
                "weight": 0.027523272178717778
            }
        ]
    },
    {
        "title": "Vue上手",
        "text": "线上尝试 Vue​\n想要快速体验 Vue，你可以直接试试我们的演练场。\n\n如果你更喜欢不用任何构建的原始 HTML，可以使用 JSFiddle 入门。\n\n如果你已经比较熟悉 Node.js 和构建工具等概念，还可以直接在浏览器中打开 StackBlitz 来尝试完整的构建设置。\n\n创建一个 Vue 应用​\n前提条件\n\n熟悉命令行\n已安装 16.0 或更高版本的 Node.js\n在本节中，我们将介绍如何在本地搭建 Vue 单页应用。创建的项目将使用基于 Vite 的构建设置，并允许我们使用 Vue 的单文件组件 (SFC)。\n\n确保你安装了最新版本的 Node.js，然后在命令行中运行以下命令 (不要带上 > 符号)：\n\n这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：\n\n如果不确定是否要开启某个功能，你可以直接按下回车键选择 No。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\n\n你现在应该已经运行起来了你的第一个 Vue 项目！请注意，生成的项目中的示例组件使用的是组合式 API 和 <script setup>，而非选项式 API。下面是一些补充提示：\n\n推荐的 IDE 配置是 Visual Studio Code + Volar 扩展。如果使用其他编辑器，参考 IDE 支持章节。\n更多工具细节，包括与后端框架的整合，我们会在工具链指南进行讨论。\n要了解构建工具 Vite 更多背后的细节，请查看 Vite 文档。\n如果你选择使用 TypeScript，请阅读 TypeScript 使用指南。\n当你准备将应用发布到生产环境时，请运行：\n\n此命令会在 ./dist 文件夹中为你的应用创建一个生产环境的构建版本。关于将应用上线生产环境的更多内容，请阅读生产环境部署指南。\n\n下一步>\n\n通过 CDN 使用 Vue​\n你可以借助 script 标签直接通过 CDN 来使用 Vue：\n\nhtml\n这里我们使用了 unpkg，但你也可以使用任何提供 npm 包服务的 CDN，例如 jsdelivr 或 cdnjs。当然，你也可以下载此文件并自行提供服务。\n\n通过 CDN 使用 Vue 时，不涉及“构建步骤”。这使得设置更加简单，并且可以用于增强静态的 HTML 或与后端框架集成。但是，你将无法使用单文件组件 (SFC) 语法。\n\n使用全局构建版本​\n上面的例子使用了全局构建版本的 Vue，该版本的所有顶层 API 都以属性的形式暴露在了全局的 Vue 对象上。这里有一个使用全局构建版本的例子：\n\nhtml\nJSFiddle 中的示例\n\n使用 ES 模块构建版本​\n在本文档的其余部分我们使用的主要是 ES 模块语法。现代浏览器大多都已原生支持 ES 模块。因此我们可以像这样通过 CDN 以及原生 ES 模块使用 Vue：\n\nhtml\n注意我们使用了 <script type=\"module\">，且导入的 CDN URL 指向的是 Vue 的 ES 模块构建版本。\n\nJSFiddle 中的示例\n\n启用 Import maps​\n在上面的示例中，我们使用了完整的 CDN URL 来导入，但在文档的其余部分中，你将看到如下代码：\n\njs\n我们可以使用导入映射表 (Import Maps) 来告诉浏览器如何定位到导入的 vue：\n\nhtml\nJSFiddle 中的示例\n\n你也可以在映射表中添加其他的依赖——但请务必确保你使用的是该库的 ES 模块版本。\n\n导入映射表的浏览器支持情况\n\n目前只有基于 Chromium 的浏览器支持导入映射表，所以我们推荐你在学习过程中使用 Chrome 或 Edge。\n\n如果你使用的是 Firefox 浏览器，则该功能默认在 108+ 版本或通过启用 about:config 中的 dom.importMaps.enabled 选项支持。\n\n如果你更喜欢那些还不支持导入映射表的浏览器，你可以使用 es-module-shims 来进行 polyfill。\n\n生产环境中的注意事项\n\n到目前为止示例中使用的都是 Vue 的开发构建版本——如果你打算在生产中通过 CDN 使用 Vue，请务必查看生产环境部署指南。\n\n拆分模块​\n随着对这份指南的逐步深入，我们可能需要将代码分割成单独的 JavaScript 文件，以便更容易管理。例如：\n\nhtml\njs\n如果直接在浏览器中打开了上面的 index.html，你会发现它抛出了一个错误，因为 ES 模块不能通过 file:// 协议工作。为了使其工作，你需要使用本地 HTTP 服务器通过 http:// 协议提供 index.html。\n\n要启动一个本地的 HTTP 服务器，请先安装 Node.js，然后通过命令行在 HTML 文件所在文件夹下运行 npx serve。你也可以使用其他任何可以基于正确的 MIME 类型服务静态文件的 HTTP 服务器。\n\n可能你也注意到了，这里导入的组件模板是内联的 JavaScript 字符串。如果你正在使用 VSCode，你可以安装 es6-string-html 扩展，然后在字符串前加上一个前缀注释 /*html*/ 以高亮语法。\n\n无需构建的组合式 API 用法​\n组合式 API 的许多示例将使用 <script setup> 语法。如果你想在无需构建的情况下使用组合式 API，请参阅 setup() 选项。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.4993231799614525
            },
            {
                "word": "对象",
                "weight": 0.2699047101125377
            },
            {
                "word": "html",
                "weight": 0.05769302748150241
            },
            {
                "word": "组件",
                "weight": 0.05769302748150241
            },
            {
                "word": "标签",
                "weight": 0.05769302748150241
            },
            {
                "word": "javascript",
                "weight": 0.05769302748150241
            }
        ]
    },
    {
        "title": "创建一个 Vue 应用",
        "text": "应用实例​\n每个 Vue 应用都是通过 createApp 函数创建一个新的 应用实例：\n\njs\n根组件​\n我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。\n\n如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。\n\njs\n虽然本指南中的许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：\n\n\n我们会在指南的后续章节中讨论如何定义和组合多个组件。在那之前，我们得先关注一个组件内到底发生了什么。\n\n挂载应用​\n应用实例必须在调用了 .mount() 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：\n\nhtml\njs\n应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。\n\n.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。\n\nDOM 中的根组件模板​\n当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板：\n\nhtml\njs\n当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。\n\n应用配置​\n应用实例会暴露一个 .config 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：\n\njs\n应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：\n\njs\n这使得 TodoDeleteButton 在应用的任何地方都是可用的。我们会在指南的后续章节中讨论关于组件和其他资源的注册。你也可以在 API 参考中浏览应用实例 API 的完整列表。\n\n确保在挂载应用实例之前完成所有应用配置！\n\n多个应用实例​\n应用实例并不只限于一个。createApp API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。\n\njs\n如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.14285714285714282
            },
            {
                "word": "函数",
                "weight": 0.14285714285714282
            },
            {
                "word": "组件",
                "weight": 0.14285714285714282
            },
            {
                "word": "对象",
                "weight": 0.14285714285714282
            },
            {
                "word": "dom",
                "weight": 0.14285714285714282
            },
            {
                "word": "css",
                "weight": 0.14285714285714282
            },
            {
                "word": "html",
                "weight": 0.14285714285714282
            }
        ]
    },
    {
        "title": "Vue模板语法",
        "text": "Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。\n\n在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。\n\n如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。\n\n文本插值​\n最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：\n\ntemplate\n双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。\n\n原始 HTML​\n双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：\n\ntemplate\nUsing text interpolation: <span style=\"color: red\">This should be red.</span>\n\nUsing v-html directive: This should be red.\n\n\n这里我们遇到了一个新的概念。这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。\n\nspan 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。\n\n安全警告\n\n在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。\n\nAttribute 绑定​\n双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令：\n\ntemplate\nv-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。\n\n简写​\n因为 v-bind 非常常用，我们提供了特定的简写语法：\n\ntemplate\n开头为 : 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。\n\n接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。\n\n布尔型 Attribute​\n布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。\n\nv-bind 在这种场景下的行为略有不同：\n\ntemplate\n当 isButtonDisabled 为真值或一个空字符串 (即 <button disabled=\"\">) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。\n\n动态绑定多个值​\n如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：\n\njs\n通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\n\ntemplate\n使用 JavaScript 表达式​\n至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：\n\ntemplate\n这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。\n\n在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n在文本插值中 (双大括号)\n在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中\n仅支持表达式​\n每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。\n\n因此，下面的例子都是无效的：\n\ntemplate\n调用函数​\n可以在绑定的表达式中使用一个组件暴露的方法：\n\ntemplate\nTIP\n\n绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。\n\n受限的全局访问​\n模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。\n\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。\n\n指令 Directives​\n指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。\n\n指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例：\n\ntemplate\n这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 <p> 元素。\n\n参数 Arguments​\n某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute：\n\ntemplate\n这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。\n\n另一个例子是 v-on 指令，它将监听 DOM 事件：\n\ntemplate\n这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。\n\n动态参数​\n同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：\n\ntemplate\n这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 \"href\"，那么这个绑定就等价于 v-bind:href。\n\n相似地，你还可以将一个函数绑定到动态的事件名称上：\n\ntemplate\n在此示例中，当 eventName 的值是 \"focus\" 时，v-on:[eventName] 就等价于 v-on:focus。\n\n动态参数值的限制​\n动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。\n\n动态参数语法的限制​\n动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：\n\ntemplate\n如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。\n\n当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：\n\ntemplate\n上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。\n\n修饰符 Modifiers​\n修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()：\n\ntemplate\n之后在讲到 v-on 和 v-model 的功能时，你将会看到其他修饰符的例子。\n\n最后，在这里你可以直观地看到完整的指令语法：",
        "tags": [
            {
                "word": "dom",
                "weight": 0.19230642209146637
            },
            {
                "word": "javascript",
                "weight": 0.19230642209146637
            },
            {
                "word": "对象",
                "weight": 0.19230642209146637
            },
            {
                "word": "事件",
                "weight": 0.19230642209146637
            },
            {
                "word": "vue",
                "weight": 0.028846788954266837
            },
            {
                "word": "html",
                "weight": 0.028846788954266837
            },
            {
                "word": "组件",
                "weight": 0.028846788954266837
            },
            {
                "word": "函数",
                "weight": 0.028846788954266837
            },
            {
                "word": "标签",
                "weight": 0.028846788954266837
            },
            {
                "word": "span",
                "weight": 0.028846788954266837
            },
            {
                "word": "v-for",
                "weight": 0.028846788954266837
            },
            {
                "word": "v-if",
                "weight": 0.028846788954266837
            }
        ]
    },
    {
        "title": "Vue响应式基础",
        "text": "声明响应式状态​\n选用选项式 API 时，会用 data 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数。Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 this) 上。\n\njs\n在演练场中尝试一下\n\n这些实例上的属性仅在实例首次创建时被添加，因此你需要确保它们都出现在 data 函数返回的对象上。若所需的值还未准备好，在必要时也可以使用 null、undefined 或者其他一些值占位。\n\n虽然也可以不在 data 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。\n\nVue 在组件实例上暴露的内置 API 使用 $ 作为前缀。它同时也为内部属性保留 _ 前缀。因此，你应该避免在顶层 data 上使用任何以这些字符作前缀的属性。\n\n响应式代理 vs. 原始值​\n在 Vue 3 中，数据是基于 JavaScript Proxy（代理） 实现响应式的。使用过 Vue 2 的用户可能需要注意下面这样的边界情况：\n\njs\n当你在赋值后再访问 this.someObject，此值已经是原来的 newObject 的一个响应式代理。与 Vue 2 不同的是，这里原始的 newObject 不会变为响应式：请确保始终通过 this 来访问响应式状态。\n\n声明方法​\n要为组件添加方法，我们需要用到 methods 选项。它应该是一个包含所有方法的对象：\n\njs\nVue 自动为 methods 中的方法绑定了永远指向组件实例的 this。这确保了方法在作为事件监听器或回调函数时始终保持正确的 this。你不应该在定义 methods 时使用箭头函数，因为箭头函数没有自己的 this 上下文。\n\njs\n和组件实例上的其他属性一样，方法也可以在模板上被访问。在模板中它们常常被用作事件监听器：\n\ntemplate\n在演练场中尝试一下\n\n在上面的例子中，increment 方法会在 <button> 被点击时调用。\n\nDOM 更新时机​\n当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。\n\n若要等待一个状态改变后的 DOM 更新完成，你可以使用 nextTick() 这个全局 API：\n\njs\n深层响应性​\n在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。\n\njs\n你也可以直接创建一个浅层响应式对象。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。\n\n有状态方法​\n在某些情况下，我们可能需要动态地创建一个方法函数，比如创建一个预置防抖的事件处理器：\n\njs\n不过这种方法对于被重用的组件来说是有问题的，因为这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响。\n\n要保持每个组件实例的防抖函数都彼此独立，我们可以改为在 created 生命周期钩子中创建这个预置防抖的函数：",
        "tags": [
            {
                "word": "对象",
                "weight": 0.21364176928134765
            },
            {
                "word": "函数",
                "weight": 0.2044909465088108
            },
            {
                "word": "vue",
                "weight": 0.17857142856960903
            },
            {
                "word": "组件",
                "weight": 0.17857142856960903
            },
            {
                "word": "数组",
                "weight": 0.11758156991866861
            },
            {
                "word": "生命周期",
                "weight": 0.026785714287988698
            },
            {
                "word": "javascript",
                "weight": 0.026785714287988698
            },
            {
                "word": "事件",
                "weight": 0.026785714287988698
            },
            {
                "word": "dom",
                "weight": 0.026785714287988698
            }
        ]
    },
    {
        "title": "Vue Class 与 Style 绑定",
        "text": "数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 class 和 style 都是 attribute，我们可以和其他 attribute 一样使用 v-bind 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 class 和 style 的 v-bind 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。\n\n绑定 HTML class​\n绑定对象​\n我们可以给 :class (v-bind:class 的缩写) 传递一个对象来动态切换 class：\n\ntemplate\n上面的语法表示 active 是否存在取决于数据属性 isActive 的真假值。\n\n你可以在对象中写多个字段来操作多个 class。此外，:class 指令也可以和一般的 class attribute 共存。举例来说，下面这样的状态：\n\njs\n配合以下模板：\n\ntemplate\n渲染的结果会是：\n\ntemplate\n当 isActive 或者 hasError 改变时，class 列表会随之更新。举例来说，如果 hasError 变为 true，class 列表也会变成 \"static active text-danger\"。\n\n绑定的对象并不一定需要写成内联字面量的形式，也可以直接绑定一个对象：\n\njs\ntemplate\n这也会渲染出相同的结果。我们也可以绑定一个返回对象的计算属性。这是一个常见且很有用的技巧：\n\njs\ntemplate\n绑定数组​\n我们可以给 :class 绑定一个数组来渲染多个 CSS class：\n\njs\ntemplate\n渲染的结果是：\n\ntemplate\n如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：\n\ntemplate\nerrorClass 会一直存在，但 activeClass 只会在 isActive 为真时才存在。\n\n然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：\n\ntemplate\n在组件上使用​\n本节假设你已经有 Vue 组件的知识基础。如果没有，你也可以暂时跳过，以后再阅读。\n\n对于只有一个根元素的组件，当你使用了 class attribute 时，这些 class 会被添加到根元素上，并与该元素上已有的 class 合并。\n\n举例来说，如果你声明了一个组件名叫 MyComponent，模板如下：\n\ntemplate\n在使用时添加一些 class：\n\ntemplate\n渲染出的 HTML 为：\n\ntemplate\nClass 的绑定也是同样的：\n\ntemplate\n当 isActive 为真时，被渲染的 HTML 会是：\n\ntemplate\n如果你的组件有多个根元素，你将需要指定哪个根元素来接收这个 class。你可以通过组件的 $attrs 属性来实现指定：\n\ntemplate\ntemplate\n这将被渲染为：\n\nhtml\n你可以在透传 Attribute 一章中了解更多组件的 attribute 继承的细节。\n\n绑定内联样式​\n绑定对象​\n:style 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 style 属性：\n\njs\ntemplate\n尽管推荐使用 camelCase，但 :style 也支持 kebab-cased 形式的 CSS 属性 key (对应其 CSS 中的实际名称)，例如：\n\ntemplate\n直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：\n\njs\ntemplate\n同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。\n\n绑定数组​\n我们还可以给 :style 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：\n\ntemplate\n自动前缀​\n当你在 :style 中使用了需要浏览器特殊前缀的 CSS 属性时，Vue 会自动为他们加上相应的前缀。Vue 是在运行时检查该属性是否支持在当前浏览器中使用。如果浏览器不支持某个属性，那么将尝试加上各个浏览器特殊前缀，以找到哪一个是被支持的。\n\n样式多值​\n你可以对一个样式属性提供多个 (不同前缀的) 值，举例来说：\n\ntemplate\n数组仅会渲染浏览器支持的最后一个值。在这个示例中，在支持不需要特别前缀的浏览器中都会渲染为 display: flex。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.21739072481756389
            },
            {
                "word": "对象",
                "weight": 0.21739072481756389
            },
            {
                "word": "数组",
                "weight": 0.21739072481756389
            },
            {
                "word": "组件",
                "weight": 0.21739072481756389
            },
            {
                "word": "css",
                "weight": 0.03260927518243609
            },
            {
                "word": "html",
                "weight": 0.03260927518243609
            },
            {
                "word": "继承",
                "weight": 0.03260927518243609
            },
            {
                "word": "javascript",
                "weight": 0.03260927518243609
            }
        ]
    },
    {
        "title": "Vue 条件渲染",
        "text": "v-if​\nv-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回真值时才被渲染。\n\ntemplate\nv-else​\n你也可以使用 v-else 为 v-if 添加一个“else 区块”。\n\ntemplate\n在演练场中尝试一下\n\n一个 v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则它将不会被识别。\n\nv-else-if​\n顾名思义，v-else-if 提供的是相应于 v-if 的“else if 区块”。它可以连续多次重复使用：\n\ntemplate\n和 v-else 类似，一个使用 v-else-if 的元素必须紧跟在一个 v-if 或一个 v-else-if 元素后面。\n\n<template> 上的 v-if​\n因为 v-if 是一个指令，他必须依附于某个元素。但如果我们想要切换不止一个元素呢？在这种情况下我们可以在一个 <template> 元素上使用 v-if，这只是一个不可见的包装器元素，最后渲染的结果并不会包含这个 <template> 元素。\n\ntemplate\nv-else 和 v-else-if 也可以在 <template> 上使用。\n\nv-show​\n另一个可以用来按条件显示一个元素的指令是 v-show。其用法基本一样：\n\ntemplate\n不同之处在于 v-show 会在 DOM 渲染中保留该元素；v-show 仅切换了该元素上名为 display 的 CSS 属性。\n\nv-show 不支持在 <template> 元素上使用，也不能和 v-else 搭配使用。\n\nv-if vs. v-show​\nv-if 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。\n\nv-if 也是惰性的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。\n\n相比之下，v-show 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。\n\n总的来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 v-show 较好；如果在运行时绑定条件很少改变，则 v-if 会更合适。\n\nv-if 和 v-for​\n警告\n\n同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。请查看风格指南获得更多信息。\n\n当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。请查看列表渲染指南获取更多细节。",
        "tags": [
            {
                "word": "v-if",
                "weight": 0.27239746690035205
            },
            {
                "word": "条件渲染",
                "weight": 0.15358223748097743
            },
            {
                "word": "v-else",
                "weight": 0.13847491041252347
            },
            {
                "word": "v-else-if",
                "weight": 0.13847491041252347
            },
            {
                "word": "vue",
                "weight": 0.08701291354767697
            },
            {
                "word": "v-for",
                "weight": 0.07962277863107145
            },
            {
                "word": "v-show",
                "weight": 0.021739130435812565
            },
            {
                "word": "dom",
                "weight": 0.021739130435812565
            },
            {
                "word": "css",
                "weight": 0.021739130435812565
            },
            {
                "word": "事件",
                "weight": 0.021739130435812565
            },
            {
                "word": "优先级",
                "weight": 0.021739130435812565
            },
            {
                "word": "列表渲染",
                "weight": 0.021739130435812565
            }
        ]
    },
    {
        "title": "Vue 列表渲染",
        "text": "v-for​\n我们可以使用 v-for 指令基于一个数组来渲染一个列表。v-for 指令的值需要使用 item in items 形式的特殊语法，其中 items 是源数据的数组，而 item 是迭代项的别名：\n\njs\ntemplate\n在 v-for 块中可以完整地访问父作用域内的属性和变量。v-for 也支持使用可选的第二个参数表示当前项的位置索引。\n\njs\ntemplate\n在演练场中尝试一下\n\nv-for 变量的作用域和下面的 JavaScript 代码很类似：\n\njs\n注意 v-for 是如何对应 forEach 回调的函数签名的。实际上，你也可以在定义 v-for 的变量别名时使用解构，和解构函数参数类似：\n\ntemplate\n对于多层嵌套的 v-for，作用域的工作方式和函数的作用域很类似。每个 v-for 作用域都可以访问到父级作用域：\n\ntemplate\n你也可以使用 of 作为分隔符来替代 in，这更接近 JavaScript 的迭代器语法：\n\ntemplate\nv-for 与对象​\n你也可以使用 v-for 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 Object.keys() 的返回值来决定。\n\njs\ntemplate\n可以通过提供第二个参数表示属性名 (例如 key)：\n\ntemplate\n第三个参数表示位置索引：\n\ntemplate\n在演练场中尝试一下\n\n在 v-for 里使用范围值​\nv-for 可以直接接受一个整数值。在这种用例中，会将该模板基于 1...n 的取值范围重复多次。\n\ntemplate\n注意此处 n 的初值是从 1 开始而非 0。\n\n<template> 上的 v-for​\n与模板上的 v-if 类似，你也可以在 <template> 标签上使用 v-for 来渲染一个包含多个元素的块。例如：\n\ntemplate\nv-for 与 v-if​\n注意\n\n同时使用 v-if 和 v-for 是不推荐的，因为这样二者的优先级不明显。请转阅风格指南查看更多细节。\n\n当它们同时存在于一个节点上时，v-if 比 v-for 的优先级更高。这意味着 v-if 的条件将无法访问到 v-for 作用域内定义的变量别名：\n\ntemplate\n在外新包装一层 <template> 再在其上使用 v-for 可以解决这个问题 (这也更加明显易读)：\n\ntemplate\n通过 key 管理状态​\nVue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。\n\n默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。\n\n为了给 Vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 key attribute：\n\ntemplate\n当你使用 <template v-for> 时，key 应该被放置在这个 <template> 容器上：\n\ntemplate\n注意\n\nkey 在这里是一个通过 v-bind 绑定的特殊 attribute。请不要和在 v-for 中使用对象里所提到的对象属性名相混淆。\n\n推荐在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。\n\nkey 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。关于 key attribute 的更多用途细节，请参阅 key API 文档。\n\n组件上使用 v-for​\n这一小节假设你已了解组件的相关知识，或者你也可以先跳过这里，之后再回来看。\n\n我们可以直接在组件上使用 v-for，和在一般的元素上使用没有区别 (别忘记提供一个 key)：\n\ntemplate\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：\n\ntemplate\n不自动将 item 注入组件的原因是，这会使组件与 v-for 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。\n\n这里是一个简单的 Todo List 的例子，展示了如何通过 v-for 来渲染一个组件列表，并向每个实例中传入不同的数据。\n\n数组变化侦测​\n变更方法​\nVue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：\n\npush()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n替换一个数组​\n变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 filter()，concat() 和 slice()，这些都不会更改原数组，而总是返回一个新数组。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：\n\njs\n你可能认为这将导致 Vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。Vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。\n\n展示过滤或排序后的结果​\n有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。\n\n举例来说：\n\njs\ntemplate\n在计算属性不可行的情况下 (例如在多层嵌套的 v-for 循环中)，你可以使用以下方法：\n\njs\ntemplate\n在计算属性中使用 reverse() 和 sort() 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：",
        "tags": [
            {
                "word": "v-for",
                "weight": 0.28659498208727746
            },
            {
                "word": "列表渲染",
                "weight": 0.12679342786211395
            },
            {
                "word": "对象",
                "weight": 0.12679342786211395
            },
            {
                "word": "组件",
                "weight": 0.115066760933497
            },
            {
                "word": "vue",
                "weight": 0.07132839289148038
            },
            {
                "word": "数组",
                "weight": 0.07132839289148038
            },
            {
                "word": "v-if",
                "weight": 0.06616358680578592
            },
            {
                "word": "优先级",
                "weight": 0.06616358680578592
            },
            {
                "word": "javascript",
                "weight": 0.017441860465116282
            },
            {
                "word": "函数",
                "weight": 0.017441860465116282
            },
            {
                "word": "标签",
                "weight": 0.017441860465116282
            },
            {
                "word": "dom",
                "weight": 0.017441860465116282
            }
        ]
    },
    {
        "title": "Vue 事件处理",
        "text": "监听事件​\n我们可以使用 v-on 指令 (简写为 @) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：v-on:click=\"handler\" 或 @click=\"handler\"。\n\n事件处理器 (handler) 的值可以是：\n\n内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 onclick 类似)。\n\n方法事件处理器：一个指向组件上定义的方法的属性名或是路径。\n\n内联事件处理器​\n内联事件处理器通常用于简单场景，例如：\n\njs\ntemplate\n在演练场中尝试一下\n\n方法事件处理器​\n随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 v-on 也可以接受一个方法名或对某个方法的调用。\n\n举例来说：\n\njs\ntemplate\n在演练场中尝试一下\n\n方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 event.target.tagName 访问到该 DOM 元素。\n\n你也可以看看为事件处理器标注类型这一章了解更多。\n\n方法与内联事件判断​\n模板编译器会通过检查 v-on 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，foo、foo.bar 和 foo['bar'] 会被视为方法事件处理器，而 foo() 和 count++ 会被视为内联事件处理器。\n\n在内联处理器中调用方法​\n除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：\n\njs\ntemplate\n在演练场中尝试一下\n\n在内联事件处理器中访问事件参数​\n有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 $event 变量，或者使用内联箭头函数：\n\ntemplate\njs\n事件修饰符​\n在处理事件时调用 event.preventDefault() 或 event.stopPropagation() 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n为解决这一问题，Vue 为 v-on 提供了事件修饰符。修饰符是用 . 表示的指令后缀，包含以下这些：\n\n.stop\n.prevent\n.self\n.capture\n.once\n.passive\ntemplate\nTIP\n\n使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 @click.prevent.self 会阻止元素及其子元素的所有点击事件的默认行为，而 @click.self.prevent 则只会阻止对元素本身的点击事件的默认行为。\n\n.capture、.once 和 .passive 修饰符与原生 addEventListener 事件相对应：\n\ntemplate\n.passive 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能。\n\nTIP\n\n请勿同时使用 .passive 和 .prevent，因为 .passive 已经向浏览器表明了你不想阻止事件的默认行为。如果你这么做了，则 .prevent 会被忽略，并且浏览器会抛出警告。\n\n按键修饰符​\n在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 v-on 或 @ 监听按键事件时添加按键修饰符。\n\ntemplate\n你可以直接使用 KeyboardEvent.key 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。\n\ntemplate\n在上面的例子中，仅会在 $event.key 为 'PageDown' 时调用事件处理。\n\n按键别名​\nVue 为一些常用的按键提供了别名：\n\n.enter\n.tab\n.delete (捕获“Delete”和“Backspace”两个按键)\n.esc\n.space\n.up\n.down\n.left\n.right\n系统按键修饰符​\n你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。\n\n.ctrl\n.alt\n.shift\n.meta\n注意\n\n在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。\n\n举例来说：\n\ntemplate\nTIP\n\n请注意，系统按键修饰符和常规按键不同。与 keyup 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，keyup.ctrl 只会在你仍然按住 ctrl 但松开了另一个键时被触发。若你单独松开 ctrl 键将不会触发。\n\n.exact 修饰符​\n.exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。\n\ntemplate\n鼠标按键修饰符​\n.left\n.right\n.middle\n这些修饰符将处理程序限定为由特定鼠标按键触发的事件。",
        "tags": [
            {
                "word": "事件",
                "weight": 0.49953665249769325
            },
            {
                "word": "vue",
                "weight": 0.18501427561650668
            },
            {
                "word": "dom",
                "weight": 0.18501427561650668
            },
            {
                "word": "javascript",
                "weight": 0.04347826542309767
            },
            {
                "word": "组件",
                "weight": 0.04347826542309767
            },
            {
                "word": "函数",
                "weight": 0.04347826542309767
            }
        ]
    },
    {
        "title": "Vue 表单输入绑定",
        "text": "在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：\n\ntemplate\nv-model 指令帮我们简化了这一步骤：\n\ntemplate\n另外，v-model 还可以用于各种不同类型的输入，<textarea>、<select> 元素。它会根据所使用的元素自动使用对应的 DOM 属性和事件组合：\n\n文本类型的 <input> 和 <textarea> 元素会绑定 value property 并侦听 input 事件；\n<input type=\"checkbox\"> 和 <input type=\"radio\"> 会绑定 checked property 并侦听 change 事件；\n<select> 会绑定 value property 并侦听 change 事件。\n注意\n\nv-model 会忽略任何表单元素上初始的 value、checked 或 selected attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用data 选项来声明该初始值。\n\n基本用法​\n文本​\ntemplate\n在演练场中尝试一下\n\n\n注意\n\n对于需要使用 IME 的语言 (中文，日文和韩文等)，你会发现 v-model 不会在 IME 输入还在拼字阶段时触发更新。如果你的确想在拼字阶段也触发更新，请直接使用自己的 input 事件监听器和 value 绑定而不要使用 v-model。\n\n多行文本​\ntemplate\n在演练场中尝试一下\n\n注意在 <textarea> 中是不支持插值表达式的。请使用 v-model 来替代：\n\ntemplate\n复选框​\n单一的复选框，绑定布尔类型值：\n\ntemplate\n在演练场中尝试一下\n\n我们也可以将多个复选框绑定到同一个数组或集合的值：\n\njs\ntemplate\n在这个例子中，checkedNames 数组将始终包含所有当前被选中的框的值。\n\n在演练场中尝试一下\n\n单选按钮​\ntemplate\n在演练场中尝试一下\n\n选择器​\n单个选择器的示例如下：\n\ntemplate\n在演练场中尝试一下\n\n注意\n\n如果 v-model 表达式的初始值不匹配任何一个选择项，<select> 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项，因为 iOS 在这种情况下不会触发一个 change 事件。因此，我们建议提供一个空值的禁用选项，如上面的例子所示。\n\n多选 (值绑定到一个数组)：\n\ntemplate\n在演练场中尝试一下\n\n选择器的选项可以使用 v-for 动态渲染：\n\njs\ntemplate\n在演练场中尝试一下\n\n值绑定​\n对于单选按钮，复选框和选择器选项，v-model 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：\n\ntemplate\n但有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 v-bind 来实现。此外，使用 v-bind 还使我们可以将选项值绑定为非字符串的数据类型。\n\n复选框​\ntemplate\ntrue-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。这里 toggle 属性的值会在选中时被设为 'yes'，取消选择时设为 'no'。你同样可以通过 v-bind 将其绑定为其他动态值：\n\ntemplate\n提示\n\ntrue-value 和 false-value attributes 不会影响 value attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。\n\n单选按钮​\ntemplate\npick 会在第一个按钮选中时被设为 first，在第二个按钮选中时被设为 second。\n\n选择器选项​\ntemplate\nv-model 同样也支持非字符串类型的值绑定！在上面这个例子中，当某个选项被选中，selected 会被设为该对象字面量值 { number: 123 }。\n\n修饰符​\n.lazy​\n默认情况下，v-model 会在每次 input 事件后更新数据 (IME 拼字阶段的状态例外)。你可以添加 lazy 修饰符来改为在每次 change 事件后更新数据：\n\ntemplate\n.number​\n如果你想让用户输入自动转换为数字，你可以在 v-model 后添加 .number 修饰符来管理输入：\n\ntemplate\n如果该值无法被 parseFloat() 处理，那么将返回原始值。\n\nnumber 修饰符会在输入框有 type=\"number\" 时自动启用。\n\n.trim​\n如果你想要默认自动去除用户输入内容中两端的空格，你可以在 v-model 后添加 .trim 修饰符：\n\ntemplate\n组件上的 v-model​\n如果你还不熟悉 Vue 的组件，那么现在可以跳过这个部分。\n\nHTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 v-model！要了解更多关于此的内容，请在组件指引中阅读配合 v-model 使用。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.3474926403227334
            },
            {
                "word": "表单输入绑定",
                "weight": 0.18339653698121647
            },
            {
                "word": "组件",
                "weight": 0.18339653698121647
            },
            {
                "word": "javascript",
                "weight": 0.0357142857143542
            },
            {
                "word": "事件",
                "weight": 0.0357142857143542
            },
            {
                "word": "dom",
                "weight": 0.0357142857143542
            },
            {
                "word": "数组",
                "weight": 0.0357142857143542
            },
            {
                "word": "v-for",
                "weight": 0.0357142857143542
            },
            {
                "word": "数据类型",
                "weight": 0.0357142857143542
            },
            {
                "word": "对象",
                "weight": 0.0357142857143542
            },
            {
                "word": "html",
                "weight": 0.0357142857143542
            }
        ]
    },
    {
        "title": "Vue 生命周期钩子",
        "text": "每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。\n\n注册周期钩子​\n举例来说，mounted 钩子可以用来在组件完成初始渲染并创建 DOM 节点后运行代码：\n\njs\n还有其他一些钩子，会在实例生命周期的不同阶段被调用，最常用的是 mounted、updated 和 unmounted。\n\n所有生命周期钩子函数的 this 上下文都会自动指向当前调用它的组件实例。注意：避免用箭头函数来定义生命周期钩子，因为如果这样的话你将无法在函数中通过 this 获取组件实例。\n\n生命周期图示​\n下面是实例生命周期的图表。你现在并不需要完全理解图中的所有内容，但以后它将是一个有用的参考。\n\n组件生命周期图示\n\n有关所有生命周期钩子及其各自用例的详细信息，请参考生命周期钩子 API 索引。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.30303005715665693
            },
            {
                "word": "生命周期",
                "weight": 0.30303005715665693
            },
            {
                "word": "组件",
                "weight": 0.30303005715665693
            },
            {
                "word": "dom",
                "weight": 0.04545491426501476
            },
            {
                "word": "函数",
                "weight": 0.04545491426501476
            }
        ]
    },
    {
        "title": "Vue 侦听器",
        "text": "基本示例​\n计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。\n\n在选项式 API 中，我们可以使用 watch 选项在每次响应式属性发生变化时触发一个函数。\n\njs\ntemplate\n在演练场中尝试一下\n\nwatch 选项也支持把键设置成用 . 分隔的路径：\n\njs\n深层侦听器​\nwatch 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数——而嵌套属性的变化不会触发。如果想侦听所有嵌套的变更，你需要深层侦听器：\n\njs\n谨慎使用\n\n深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。\n\n即时回调的侦听器​\nwatch 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。\n\n我们可以用一个对象来声明侦听器，这个对象有 handler 方法和 immediate: true 选项，这样便能强制回调函数立即执行：\n\njs\n回调函数的初次执行就发生在 created 钩子之前。Vue 此时已经处理了 data、computed 和 methods 选项，所以这些属性在第一次调用时就是可用的。\n\n回调的触发时机​\n当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。\n\n默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。\n\n如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，你需要指明 flush: 'post' 选项：\n\njs\nthis.$watch()​\n我们也可以使用组件实例的 $watch() 方法来命令式地创建一个侦听器：\n\njs\n如果要在特定条件下设置一个侦听器，或者只侦听响应用户交互的内容，这方法很有用。它还允许你提前停止该侦听器。\n\n停止侦听器​\n用 watch 选项或者 $watch() 实例方法声明的侦听器，会在宿主组件卸载时自动停止。因此，在大多数场景下，你无需关心怎么停止它。\n\n在少数情况下，你的确需要在组件卸载之前就停止一个侦听器，这时可以调用 $watch() API 返回的函数：",
        "tags": [
            {
                "word": "vue",
                "weight": 0.44225940081600196
            },
            {
                "word": "dom",
                "weight": 0.23341575413745363
            },
            {
                "word": "组件",
                "weight": 0.23341575413745363
            },
            {
                "word": "函数",
                "weight": 0.04545454545454546
            },
            {
                "word": "对象",
                "weight": 0.04545454545454546
            }
        ]
    },
    {
        "title": "Vue 模板引用",
        "text": "虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 ref attribute：\n\ntemplate\nref 是一个特殊的 attribute，和 v-for 章节中提到的 key 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。\n\n访问模板引用​\n挂载结束后引用都会被暴露在 this.$refs 之上：\n\nvue\n注意，你只可以在组件挂载后才能访问模板引用。如果你想在模板中的表达式上访问 $refs.input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！\n\nv-for 中的模板引用​\n需要 v3.2.25 及以上版本\n\n当在 v-for 中使用模板引用时，相应的引用中包含的值是一个数组：\n\nvue\n在演练场中尝试一下\n\n应该注意的是，ref 数组并不保证与源数组相同的顺序。\n\n函数模板引用​\n除了使用字符串值作名字，ref attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：\n\ntemplate\n注意我们这里需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。你当然也可以绑定一个组件方法而不是内联函数。\n\n组件上的 ref​\n这一小节假设你已了解组件的相关知识，或者你也可以先跳过这里，之后再回来看。\n\n模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：\n\nvue\n如果一个子组件使用的是选项式 API ，被引用的组件实例和该子组件的 this 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。\n\nexpose 选项可以用于限制对子组件实例的访问：\n\njs\n在上面这个例子中，父组件通过模板引用访问到子组件实例后，仅能访问 publicData 和 publicMethod。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.16666666666666663
            },
            {
                "word": "dom",
                "weight": 0.16666666666666663
            },
            {
                "word": "v-for",
                "weight": 0.16666666666666663
            },
            {
                "word": "组件",
                "weight": 0.16666666666666663
            },
            {
                "word": "数组",
                "weight": 0.16666666666666663
            },
            {
                "word": "函数",
                "weight": 0.16666666666666663
            }
        ]
    },
    {
        "title": "Vue 组件基础",
        "text": "组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。在实际应用中，组件常常被组织成层层嵌套的树状结构：\n\n组件树\n\n这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。Vue 同样也能很好地配合原生 Web Component。如果你想知道 Vue 组件与原生 Web Components 之间的关系，可以阅读此章节。\n\n定义一个组件​\n当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 .vue 文件中，这被叫做单文件组件 (简称 SFC)：\n\nvue\n当不使用构建步骤时，一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义：\n\njs\n这里的模板是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它。你也可以使用 ID 选择器来指向一个元素 (通常是原生的 <template> 元素)，Vue 将会使用其内容作为模板来源。\n\n上面的例子中定义了一个组件，并在一个 .js 文件里默认导出了它自己，但你也可以通过具名导出在一个文件中导出多个组件。\n\n使用组件​\nTIP\n\n我们会在接下来的指引中使用 SFC 语法，无论你是否使用构建步骤，组件相关的概念都是相同的。示例一节中展示了两种场景中的组件使用情况。\n\n要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 ButtonCounter.vue 的文件中，这个组件将会以默认导出的形式被暴露给外部。\n\nvue\n若要将导入的组件暴露给模板，我们需要在 components 选项上注册它。这个组件将会以其注册时的名字作为模板中的标签名。\n\n当然，你也可以全局地注册一个组件，使得它在当前应用中的任何组件上都可以使用，而不需要额外再导入。关于组件的全局注册和局部注册两种方式的利弊，我们放在了组件注册这一章节中专门讨论。\n\n组件可以被重用任意多次：\n\ntemplate\n在演练场中尝试一下\n\n你会注意到，每当点击这些按钮时，每一个组件都维护着自己的状态，是不同的 count。这是因为每当你使用一个组件，就创建了一个新的实例。\n\n在单文件组件中，推荐为子组件使用 PascalCase 的标签名，以此来和原生的 HTML 元素作区分。虽然原生 HTML 标签名是不区分大小写的，但 Vue 单文件组件是可以在编译中区分大小写的。我们也可以使用 /> 来关闭一个标签。\n\n如果你是直接在 DOM 中书写模板 (例如原生 <template> 元素的内容)，模板的编译需要遵从浏览器中 HTML 的解析行为。在这种情况下，你应该需要使用 kebab-case 形式并显式地关闭这些组件的标签。\n\ntemplate\n请看 DOM 模板解析注意事项了解更多细节。\n\n传递 props​\n如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须向组件中传递数据，例如每篇文章标题和内容，这就会使用到 props。\n\nProps 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 props 选项：\n\nvue\n当一个值被传递给 prop 时，它将成为该组件实例上的一个属性。该属性的值可以像其他组件属性一样，在模板和组件的 this 上下文中访问。\n\n一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值。\n\n当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：\n\ntemplate\n在实际应用中，我们可能在父组件中会有如下的一个博客文章数组：\n\njs\n这种情况下，我们可以使用 v-for 来渲染它们：\n\ntemplate\n在演练场中尝试一下\n\n留意我们是如何使用 v-bind 来传递动态 prop 值的。当事先不知道要渲染的确切内容时，这一点特别有用。\n\n以上就是目前你需要了解的关于 props 的全部了。如果你看完本章节后还想知道更多细节，我们推荐你深入阅读关于 props 的完整指引。\n\n监听事件​\n让我们继续关注我们的 <BlogPost> 组件。我们会发现有时候它需要与父组件进行交互。例如，要在此处实现 A11y 的需求，将博客文章的文字能够放大，而页面的其余部分仍使用默认字号。\n\n在父组件中，我们可以添加一个 postFontSize 数据属性来实现这个效果：\n\njs\n在模板中用它来控制所有博客文章的字体大小：\n\ntemplate\n然后，给 <BlogPost> 组件添加一个按钮：\n\nvue\n这个按钮目前还没有做任何事情，我们想要点击这个按钮来告诉父组件它应该放大所有博客文章的文字。要解决这个问题，组件实例提供了一个自定义事件系统。父组件可以通过 v-on 或 @ 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样：\n\ntemplate\n子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件：\n\nvue\n因为有了 @enlarge-text=\"postFontSize += 0.1\" 的监听，父组件会接收这一事件，从而更新 postFontSize 的值。\n\n在演练场中尝试一下\n\n我们可以通过 emits 选项来声明需要抛出的事件：\n\nvue\n这声明了一个组件可能触发的所有事件，还可以对事件的参数进行验证。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。\n\n以上就是目前你需要了解的关于组件自定义事件的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读组件事件章节。\n\n通过插槽来分配内容​\n一些情况下我们会希望能和 HTML 元素一样向组件中传递内容：\n\ntemplate\n我们期望能渲染成这样：\n\nThis is an Error for Demo Purposes\n\nSomething bad happened.\n\n这可以通过 Vue 的自定义 <slot> 元素来实现：\n\nvue\n如上所示，我们使用 <slot> 作为一个占位符，父组件传递进来的内容就会渲染在这里。\n\n在演练场中尝试一下\n\n以上就是目前你需要了解的关于插槽的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读组件插槽章节。\n\n动态组件​\n有些场景会需要在两个组件间来回切换，比如 Tab 界面：\n\n在演练场中查看示例\n\n上面的例子是通过 Vue 的 <component> 元素和特殊的 is attribute 实现的：\n\ntemplate\n在上面的例子中，被传给 :is 的值可以是以下几种：\n\n被注册的组件名\n导入的组件对象\n你也可以使用 is attribute 来创建一般的 HTML 元素。\n\n当使用 <component :is=\"...\"> 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 <KeepAlive> 组件强制被切换掉的组件仍然保持“存活”的状态。\n\nDOM 模板解析注意事项​\n如果你想在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串。由于浏览器的原生 HTML 解析行为限制，有一些需要注意的事项。\n\nTIP\n\n请注意下面讨论只适用于直接在 DOM 中编写模板的情况。如果你使用来自以下来源的字符串模板，就不需要顾虑这些限制了：\n\n单文件组件\n内联模板字符串 (例如 template: '...')\n<script type=\"text/x-template\">\n大小写区分​\nHTML 标签和属性名称是不分大小写的，所以浏览器会把任何大写的字符解释为小写。这意味着当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase 形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式：\n\njs\ntemplate\n闭合标签​\n我们在上面的例子中已经使用过了闭合标签 (self-closing tag)：\n\ntemplate\n这是因为 Vue 的模板解析器支持任意标签使用 /> 作为标签关闭的标志。\n\n然而在 DOM 模板中，我们必须显式地写出关闭标签：\n\ntemplate\n这是由于 HTML 只允许一小部分特殊的元素省略其关闭标签，最常见的就是 <input> 和 <img>。对于其他的元素来说，如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束，用下面这个代码片段举例来说：\n\ntemplate\n将被解析为：\n\ntemplate\n元素位置限制​\n某些 HTML 元素对于放在其中的元素类型有限制，例如 <ul>，<ol>，<table> 和 <select>，相应的，某些元素仅在放置于特定元素中时才会显示，例如 <li>，<tr> 和 <option>。\n\n这将导致在使用带有此类限制元素的组件时出现问题。例如：\n\ntemplate\n自定义的组件 <blog-post-row> 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 is attribute 作为一种解决方案：\n\ntemplate\nTIP\n\n当使用在原生 HTML 元素上时，is 的值必须加上前缀 vue: 才可以被解析为一个 Vue 组件。这一点是必要的，为了避免和原生的自定义内置元素相混淆。\n\n以上就是你需要了解的关于 DOM 模板解析的所有注意事项，同时也是 Vue 基础部分的所有内容。祝贺你！虽然还有很多需要学习的，但你可以先暂停一下，去用 Vue 做一些有趣的东西，或者研究一些示例。\n\n完成了本页的阅读后，回顾一下你刚才所学到的知识，如果还想知道更多细节，我们推荐你继续阅读关于组件的完整指引。",
        "tags": [
            {
                "word": "组件",
                "weight": 0.27742586164047517
            },
            {
                "word": "对象",
                "weight": 0.12054866893706792
            },
            {
                "word": "标签",
                "weight": 0.12054866893706792
            },
            {
                "word": "事件",
                "weight": 0.12054866893706792
            },
            {
                "word": "html",
                "weight": 0.06736277644566448
            },
            {
                "word": "javascript",
                "weight": 0.06736277644566448
            },
            {
                "word": "dom",
                "weight": 0.06736277644566448
            },
            {
                "word": "vue",
                "weight": 0.06329086884759921
            },
            {
                "word": "标题",
                "weight": 0.06329086884759921
            },
            {
                "word": "数组",
                "weight": 0.01612903225806452
            },
            {
                "word": "v-for",
                "weight": 0.01612903225806452
            }
        ]
    },
    {
        "title": "深入 Vue 组件：组件注册",
        "text": "此章节假设你已经看过了组件基础。若你还不了解组件是什么，请先阅读该章节。\n\n一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。\n\n全局注册​\n我们可以使用 Vue 应用实例的 app.component() 方法，让组件在当前 Vue 应用中全局可用。\n\njs\n如果使用单文件组件，你可以注册被导入的 .vue 文件：\n\njs\napp.component() 方法可以被链式调用：\n\njs\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\ntemplate\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在彼此内部使用。\n\n局部注册​\n全局注册虽然很方便，但有以下几个问题：\n\n全局注册，但并没有被使用的组件无法在生产打包时被自动移除 (也叫“tree-shaking”)。如果你全局注册了一个组件，即使它并没有被实际使用，它仍然会出现在打包后的 JS 文件中。\n\n全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，不太容易定位子组件的实现。和使用过多的全局变量一样，这可能会影响应用长期的可维护性。\n\n相比之下，局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n局部注册需要使用 components 选项：\n\nvue\n对于每个 components 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\njs\n请注意：局部注册的组件在后代组件中并不可用。在这个例子中，ComponentA 注册后仅在当前组件可用，而在任何的子组件或更深层的子组件中都不可用。\n\n组件名格式​\n在整个指引中，我们都使用 PascalCase 作为组件名的注册格式，这是因为：\n\nPascalCase 是合法的 JavaScript 标识符。这使得在 JavaScript 中导入和注册组件都很容易，同时 IDE 也能提供较好的自动补全。\n\n<PascalCase /> 在模板中更明显地表明了这是一个 Vue 组件，而不是原生 HTML 元素。同时也能够将 Vue 组件和自定义元素 (web components) 区分开来。\n\n在单文件组件和内联字符串模板中，我们都推荐这样做。但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 DOM 模板解析注意事项。\n\n为了方便，Vue 支持将模板中使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 MyComponent 为名注册的组件，在模板中可以通过 <MyComponent> 或 <my-component> 引用。这让我们能够使用同样的 JavaScript 组件注册代码来配合不同来源的模板。",
        "tags": [
            {
                "word": "组件",
                "weight": 0.47872424074966274
            },
            {
                "word": "vue",
                "weight": 0.17730432375274974
            },
            {
                "word": "javascript",
                "weight": 0.17730432375274974
            },
            {
                "word": "对象",
                "weight": 0.041666777936209376
            },
            {
                "word": "html",
                "weight": 0.041666777936209376
            },
            {
                "word": "标签",
                "weight": 0.041666777936209376
            },
            {
                "word": "dom",
                "weight": 0.041666777936209376
            }
        ]
    },
    {
        "title": "深入 Vue 组件：Props",
        "text": "此章节假设你已经看过了组件基础。若你还不了解组件是什么，请先阅读该章节。\n\nProps 声明​\n一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在专门的章节中讨论)。\n\nprops 需要使用 props 选项来定义：\n\njs\n除了使用字符串数组来声明 prop 外，还可以使用对象的形式：\n\njs\n对于以对象形式声明中的每个属性，key 是 prop 的名称，而值则是该 prop 预期类型的构造函数。比如，如果要求一个 prop 的值是 number 类型，则可使用 Number 构造函数作为其声明的值。\n\n对象形式的 props 声明不仅可以一定程度上作为组件的文档，而且如果其他开发者在使用你的组件时传递了错误的类型，也会在浏览器控制台中抛出警告。我们将在本章节稍后进一步讨论有关 prop 校验的更多细节。\n\nTypeScript 用户请参考：为组件 Props 标注类型 \n\n传递 prop 的细节​\nProp 名字格式​\n如果一个 prop 的名字很长，应使用 camelCase 形式，因为它们是合法的 JavaScript 标识符，可以直接在模板的表达式中使用，也可以避免在作为属性 key 名时必须加上引号。\n\njs\ntemplate\n虽然理论上你也可以在向子组件传递 props 时使用 camelCase 形式 (使用 DOM 模板时例外)，但实际上为了和 HTML attribute 对齐，我们通常会将其写为 kebab-case 形式：\n\ntemplate\n对于组件名我们推荐使用 PascalCase，因为这提高了模板的可读性，能帮助我们区分 Vue 组件和原生 HTML 元素。然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格。\n\n静态 vs. 动态 Prop​\n至此，你已经见过了很多像这样的静态值形式的 props：\n\ntemplate\n相应地，还有使用 v-bind 或缩写 : 来进行动态绑定的 props：\n\ntemplate\n传递不同的值类型​\n在上述的两个例子中，我们只传入了字符串值，但实际上任何类型的值都可以作为 props 的值被传递。\n\nNumber​\ntemplate\nBoolean​\ntemplate\nArray​\ntemplate\nObject​\ntemplate\n使用一个对象绑定多个 prop​\n如果你想要将一个对象的所有属性都当作 props 传入，你可以使用没有参数的 v-bind，即只使用 v-bind 而非 :prop-name。例如，这里有一个 post 对象：\n\njs\n以及下面的模板：\n\ntemplate\n而这实际上等价于：\n\ntemplate\n单向数据流​\n所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。\n\n另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你不应该在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告：\n\njs\n导致你想要更改一个 prop 的需求通常来源于以下两种场景：\n\nprop 被用于传入初始值；而子组件想在之后将其作为一个局部数据属性。在这种情况下，最好是新定义一个局部数据属性，从 props 上获取初始值即可：\n\njs\n需要对传入的 prop 值做进一步的转换。在这种情况中，最好是基于该 prop 值定义一个计算属性：\n\njs\n更改对象 / 数组类型的 props​\n当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然可以更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。\n\n这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该抛出一个事件来通知父组件做出改变。\n\nProp 校验​\nVue 组件可以更细致地声明对传入的 props 的校验要求。比如我们上面已经看到过的类型声明，如果传入的值不满足类型要求，Vue 会在浏览器控制台中抛出警告来提醒使用者。这在开发给其他开发者使用的组件时非常有用。\n\n要声明对 props 的校验，你可以向 props 选项提供一个带有 props 校验选项的对象，例如：\n\njs\n一些补充细节：\n\n所有 prop 默认都是可选的，除非声明了 required: true。\n\n除 Boolean 外的未传递的可选 prop 将会有一个默认值 undefined。\n\nBoolean 类型的未传递 prop 将被转换为 false。这可以通过为它设置 default 来更改——例如：设置为 default: undefined 将与非布尔类型的 prop 的行为保持一致。\n\n如果声明了 default 值，那么在 prop 的值被解析为 undefined 时，无论 prop 是未被传递还是显式指明的 undefined，都会改为 default 值。\n\n当 prop 的校验失败后，Vue 会抛出一个控制台警告 (在开发模式下)。\n\n注意\n\n注意 prop 的校验是在组件实例被创建之前，所以实例的属性 (比如 data、computed 等) 将在 default 或 validator 函数中不可用。\n\n运行时类型检查​\n校验选项中的 type 可以是下列这些原生构造函数：\n\nString\nNumber\nBoolean\nArray\nObject\nDate\nFunction\nSymbol\n另外，type 也可以是自定义的类或构造函数，Vue 将会通过 instanceof 来检查类型是否匹配。例如下面这个类：\n\njs\n你可以将其作为一个 prop 的类型：\n\njs\nVue 会通过 instanceof Person 来校验 author prop 的值是否是 Person 类的一个实例。\n\nBoolean 类型转换​\n为了更贴近原生 boolean attributes 的行为，声明为 Boolean 类型的 props 有特别的类型转换规则。以带有如下声明的 <MyComponent> 组件为例：\n\njs\n该组件可以被这样使用：\n\ntemplate\n当一个 prop 被声明为允许多种类型时，例如：\n\njs\n无论声明类型的顺序如何，Boolean 类型的特殊转换规则都会被应用。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.22627377363968648
            },
            {
                "word": "对象",
                "weight": 0.22627377363968648
            },
            {
                "word": "组件",
                "weight": 0.1194212527150405
            },
            {
                "word": "数组",
                "weight": 0.1194212527150405
            },
            {
                "word": "函数",
                "weight": 0.1194212527150405
            },
            {
                "word": "javascript",
                "weight": 0.1194212527150405
            },
            {
                "word": "dom",
                "weight": 0.023255813953488375
            },
            {
                "word": "html",
                "weight": 0.023255813953488375
            },
            {
                "word": "事件",
                "weight": 0.023255813953488375
            }
        ]
    },
    {
        "title": "深入 Vue 组件：组件事件",
        "text": "此章节假设你已经看过了组件基础。若你还不了解组件是什么，请先阅读该章节。\n\n触发与监听事件​\n在组件的模板表达式中，可以直接使用 $emit 方法触发自定义事件 (例如：在 v-on 的处理函数中)：\n\ntemplate\n$emit() 方法在组件实例上也同样以 this.$emit() 的形式可用：\n\njs\n父组件可以通过 v-on (缩写为 @) 来监听事件：\n\ntemplate\n同样，组件的事件监听器也支持 .once 修饰符：\n\ntemplate\n像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 prop 大小写格式一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。\n\nTIP\n\n和原生 DOM 事件不一样，组件触发的事件没有冒泡机制。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个全局状态管理方案。\n\n事件参数​\n有时候我们会需要在触发事件时附带一个特定的值。举例来说，我们想要 <BlogPost> 组件来管理文本会缩放得多大。在这个场景下，我们可以给 $emit 提供一个额外的参数：\n\ntemplate\n然后我们在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此函数会接收到事件附带的参数：\n\ntemplate\n或者，也可以用一个组件方法来作为事件处理函数：\n\ntemplate\n该方法也会接收到事件所传递的参数：\n\njs\nTIP\n\n所有传入 $emit() 的额外参数都会被直接传向监听器。举例来说，$emit('foo', 1, 2, 3) 触发后，监听器函数将会收到这三个参数值。\n\n声明触发的事件​\n组件可以显式地通过 emits 选项来声明它要触发的事件：\n\njs\n这个 emits 选项还支持对象语法，它允许我们对触发事件的参数进行验证：\n\njs\nTypeScript 用户请参考：如何为组件所抛出的事件标注类型。\n\n尽管事件声明是可选的，我们还是推荐你完整地声明所有要触发的事件，以此在代码中作为文档记录组件的用法。同时，事件声明能让 Vue 更好地将事件和透传 attribute 作出区分，从而避免一些由第三方代码触发的自定义 DOM 事件所导致的边界情况。\n\nTIP\n\n如果一个原生事件的名字 (例如 click) 被定义在 emits 选项中，则监听器只会监听组件触发的 click 事件而不会再响应原生的 click 事件。\n\n事件校验​\n和对 props 添加类型校验的方式类似，所有触发的事件也可以使用对象形式来描述。\n\n要为事件添加校验，那么事件可以被赋值为一个函数，接受的参数就是抛出事件时传入 this.$emit 的内容，返回一个布尔值来表明事件是否合法。",
        "tags": [
            {
                "word": "组件",
                "weight": 0.36145602858687936
            },
            {
                "word": "事件",
                "weight": 0.25795898431611325
            },
            {
                "word": "dom",
                "weight": 0.14334142035737032
            },
            {
                "word": "vue",
                "weight": 0.13611997122425182
            },
            {
                "word": "函数",
                "weight": 0.03370786517179494
            },
            {
                "word": "状态管理",
                "weight": 0.03370786517179494
            },
            {
                "word": "对象",
                "weight": 0.03370786517179494
            }
        ]
    },
    {
        "title": "深入 Vue 组件：组件 v-model",
        "text": "v-model 可以在组件上使用以实现双向绑定。\n\n首先让我们回忆一下 v-model 在原生元素上的用法：\n\ntemplate\n在代码背后，模板编译器会对 v-model 进行更冗长的等价展开。因此上面的代码其实等价于下面这段：\n\ntemplate\n而当使用在一个组件上时，v-model 会被展开为如下的形式：\n\ntemplate\n要让这个例子实际工作起来，<CustomInput> 组件内部需要做两件事：\n\n将内部原生 <input> 元素的 value attribute 绑定到 modelValue prop\n当原生的 input 事件触发时，触发一个携带了新值的 update:modelValue 自定义事件\n这里是相应的代码：\n\nvue\n现在 v-model 可以在这个组件上正常工作了：\n\ntemplate\n在演练场中尝试一下\n\n另一种在组件内实现 v-model 的方式是使用一个可写的，同时具有 getter 和 setter 的 computed 属性。get 方法需返回 modelValue prop，而 set 方法需触发相应的事件：\n\nvue\nv-model 的参数​\n默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字：\n\ntemplate\n在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值：\n\nvue\n在演练场中尝试一下\n\n多个 v-model 绑定​\n利用刚才在 v-model 参数小节中学到的指定参数与事件名的技巧，我们可以在单个组件实例上创建多个 v-model 双向绑定。\n\n组件上的每一个 v-model 都会同步不同的 prop，而无需额外的选项：\n\ntemplate\nvue\n在演练场中尝试一下\n\n处理 v-model 修饰符​\n在学习输入绑定时，我们知道了 v-model 有一些内置的修饰符，例如 .trim，.number 和 .lazy。在某些场景下，你可能想要一个自定义组件的 v-model 支持自定义的修饰符。\n\n我们来创建一个自定义的修饰符 capitalize，它会自动将 v-model 绑定输入的字符串值第一个字母转为大写：\n\ntemplate\n组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象：\n\nvue\n注意这里组件的 modelModifiers prop 包含了 capitalize 且其值为 true，因为它在模板中的 v-model 绑定 v-model.capitalize=\"myText\" 上被使用了。\n\n有了这个 prop，我们就可以检查 modelModifiers 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <input /> 元素触发 input 事件时将值的首字母大写：\n\nvue\n在演练场中尝试一下\n\n对于又有参数又有修饰符的 v-model 绑定，生成的 prop 名将是 arg + \"Modifiers\"。举例来说：\n\ntemplate\n相应的声明应该是：",
        "tags": [
            {
                "word": "组件",
                "weight": 0.5298945137848932
            },
            {
                "word": "vue",
                "weight": 0.28642974854425124
            },
            {
                "word": "事件",
                "weight": 0.06122524589028523
            },
            {
                "word": "对象",
                "weight": 0.06122524589028523
            },
            {
                "word": "函数",
                "weight": 0.06122524589028523
            }
        ]
    },
    {
        "title": "深入 Vue 组件：透传 Attributes",
        "text": "Attributes 继承​\n“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。\n\n当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。举例来说，假如我们有一个 <MyButton> 组件，它的模板长这样：\n\ntemplate\n一个父组件使用了这个组件，并且传入了 class：\n\ntemplate\n最后渲染出的 DOM 结果是：\n\nhtml\n这里，<MyButton> 并没有将 class 声明为一个它所接受的 prop，所以 class 被视作透传 attribute，自动透传到了 <MyButton> 的根元素上。\n\n对 class 和 style 的合并​\n如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。如果我们将之前的 <MyButton> 组件的模板改成这样：\n\ntemplate\n则最后渲染出的 DOM 结果会变成：\n\nhtml\nv-on 监听器继承​\n同样的规则也适用于 v-on 事件监听器：\n\ntemplate\nclick 监听器会被添加到 <MyButton> 的根元素，即那个原生的 <button> 元素之上。当原生的 <button> 被点击，会触发父组件的 onClick 方法。同样的，如果原生 button 元素自身也通过 v-on 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。\n\n深层组件继承​\n有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <MyButton>，让它在根节点上渲染 <BaseButton>：\n\ntemplate\n此时 <MyButton> 接收的透传 attribute 会直接继续传给 <BaseButton>。\n\n请注意：\n\n透传的 attribute 不会包含 <MyButton> 上声明过的 props 或是针对 emits 声明事件的 v-on 侦听函数，换句话说，声明过的 props 和侦听函数被 <MyButton>“消费”了。\n\n透传的 attribute 若符合声明，也可以作为 props 传入 <BaseButton>。\n\n禁用 Attributes 继承​\n如果你不想要一个组件自动地继承 attribute，你可以在组件选项中设置 inheritAttrs: false。\n\n最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。\n\n这些透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。\n\ntemplate\n这个 $attrs 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等。\n\n有几点需要注意：\n\n和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs['foo-bar'] 来访问。\n\n像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。\n\n现在我们要再次使用一下之前小节中的 <MyButton> 组件例子。有时候我们可能为了样式，需要在 <button> 元素外包装一层 <div>：\n\ntemplate\n我们想要所有像 class 和 v-on 监听器这样的透传 attribute 都应用在内部的 <button> 上而不是外层的 <div> 上。我们可以通过设定 inheritAttrs: false 和使用 v-bind=\"$attrs\" 来实现：\n\ntemplate\n小提示：没有参数的 v-bind 会将一个对象的所有属性都作为 attribute 应用到目标元素上。\n\n多根节点的 Attributes 继承​\n和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。\n\ntemplate\n如果 <CustomLayout> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。\n\ntemplate\n如果 $attrs 被显式绑定，则不会有警告：\n\ntemplate\n在 JavaScript 中访问透传 Attributes​\n如果需要，你可以通过 $attrs 这个实例属性来访问组件的所有透传 attribute：",
        "tags": [
            {
                "word": "组件",
                "weight": 0.3603581821693004
            },
            {
                "word": "vue",
                "weight": 0.19019127928570193
            },
            {
                "word": "继承",
                "weight": 0.19019127928570193
            },
            {
                "word": "事件",
                "weight": 0.03703703703704231
            },
            {
                "word": "dom",
                "weight": 0.03703703703704231
            },
            {
                "word": "html",
                "weight": 0.03703703703704231
            },
            {
                "word": "函数",
                "weight": 0.03703703703704231
            },
            {
                "word": "对象",
                "weight": 0.03703703703704231
            },
            {
                "word": "javascript",
                "weight": 0.03703703703704231
            },
            {
                "word": "div",
                "weight": 0.03703703703704231
            }
        ]
    },
    {
        "title": "深入 Vue 组件：插槽 Slots",
        "text": "插槽内容与出口​\n在之前的章节中，我们已经了解到组件能够接收任意类型的 JavaScript 值作为 props，但组件要如何接收模板内容呢？在某些场景中，我们可能想要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段。\n\n举例来说，这里有一个 <FancyButton> 组件，可以像这样使用：\n\ntemplate\n而 <FancyButton> 的模板是这样的：\n\ntemplate\n<slot> 元素是一个插槽出口 (slot outlet)，标示了父元素提供的插槽内容 (slot content) 将在哪里被渲染。\n\n插槽图示\n\n最终渲染出的 DOM 是这样：\n\nhtml\n在演练场中尝试一下\n\n通过使用插槽，<FancyButton> 仅负责渲染外层的 <button> (以及相应的样式)，而其内部的内容由父组件提供。\n\n理解插槽的另一种方式是和下面的 JavaScript 函数作类比，其概念是类似的：\n\njs\n插槽内容可以是任意合法的模板内容，不局限于文本。例如我们可以传入多个元素，甚至是组件：\n\ntemplate\n在演练场中尝试一下\n\n通过使用插槽，<FancyButton> 组件更加灵活和具有可复用性。现在组件可以用在不同的地方渲染各异的内容，但同时还保证都具有相同的样式。\n\nVue 组件的插槽机制是受原生 Web Component <slot> 元素的启发而诞生，同时还做了一些功能拓展，这些拓展的功能我们后面会学习到。\n\n渲染作用域​\n插槽内容可以访问到父组件的数据作用域，因为插槽内容本身是在父组件模板中定义的。举例来说：\n\ntemplate\n这里的两个 {{ message }} 插值表达式渲染的内容都是一样的。\n\n插槽内容无法访问子组件的数据。Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。换言之：\n\n父组件模板中的表达式只能访问父组件的作用域；子组件模板中的表达式只能访问子组件的作用域。\n\n默认内容​\n在外部没有提供任何内容的情况下，可以为插槽指定默认内容。比如有这样一个 <SubmitButton> 组件：\n\ntemplate\n如果我们想在父组件没有提供任何插槽内容时在 <button> 内渲染“Submit”，只需要将“Submit”写在 <slot> 标签之间来作为默认内容：\n\ntemplate\n现在，当我们在父组件中使用 <SubmitButton> 且没有提供任何插槽内容时：\n\ntemplate\n“Submit”将会被作为默认内容渲染：\n\nhtml\n但如果我们提供了插槽内容：\n\ntemplate\n那么被显式提供的内容会取代默认内容：\n\nhtml\n在演练场中尝试一下\n\n具名插槽​\n有时在一个组件中包含多个插槽出口是很有用的。举例来说，在一个 <BaseLayout> 组件中，有如下模板：\n\ntemplate\n对于这种场景，<slot> 元素可以有一个特殊的 attribute name，用来给各个插槽分配唯一的 ID，以确定每一处要渲染的内容：\n\ntemplate\n这类带 name 的插槽被称为具名插槽 (named slots)。没有提供 name 的 <slot> 出口会隐式地命名为“default”。\n\n在父组件中使用 <BaseLayout> 时，我们需要一种方式将多个插槽内容传入到各自目标插槽的出口。此时就需要用到具名插槽了：\n\n要为具名插槽传入内容，我们需要使用一个含 v-slot 指令的 <template> 元素，并将目标插槽的名字传给该指令：\n\ntemplate\nv-slot 有对应的简写 #，因此 <template v-slot:header> 可以简写为 <template #header>。其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\n具名插槽图示\n\n下面我们给出完整的、向 <BaseLayout> 传递插槽内容的代码，指令均使用的是缩写形式：\n\ntemplate\n当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <template> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：\n\ntemplate\n现在 <template> 元素中的所有内容都将被传递到相应的插槽。最终渲染出的 HTML 如下：\n\nhtml\n在演练场中尝试一下\n\n使用 JavaScript 函数来类比可能更有助于你来理解具名插槽：\n\njs\n动态插槽名​\n动态指令参数在 v-slot 上也是有效的，即可以定义下面这样的动态插槽名：\n\ntemplate\n注意这里的表达式和动态指令参数受相同的语法限制。\n\n作用域插槽​\n在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时使用父组件域内和子组件域内的数据。要做到这一点，我们需要一种方法来让子组件在渲染时将一部分数据提供给插槽。\n\n我们也确实有办法这么做！可以像对组件传递 props 那样，向一个插槽的出口上传递 attributes：\n\ntemplate\n当需要接收插槽 props 时，默认插槽和具名插槽的使用方式有一些小区别。下面我们将先展示默认插槽如何接受 props，通过子组件标签上的 v-slot 指令，直接接收到了一个插槽 props 对象：\n\ntemplate\nscoped slots diagram\n\n在演练场中尝试一下\n\n子组件传入插槽的 props 作为了 v-slot 指令的值，可以在插槽内的表达式中访问。\n\n你可以将作用域插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\n\njs\n实际上，这已经和作用域插槽的最终代码编译结果、以及手动编写渲染函数时使用作用域插槽的方式非常类似了。\n\nv-slot=\"slotProps\" 可以类比这里的函数签名，和函数的参数类似，我们也可以在 v-slot 中使用解构：\n\ntemplate\n具名作用域插槽​\n具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 v-slot 指令的值被访问到：v-slot:name=\"slotProps\"。当使用缩写时是这样：\n\ntemplate\n向具名插槽中传入 props：\n\ntemplate\n注意插槽上的 name 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。因此最终 headerProps 的结果是 { message: 'hello' }。\n\n如果你混用了具名插槽与默认插槽，则需要为默认插槽使用显式的 <template> 标签。尝试直接为组件添加 v-slot 指令将导致编译错误。这是为了避免因默认插槽的 props 的作用域而困惑。举例：\n\ntemplate\n为默认插槽使用显式的 <template> 标签有助于更清晰地指出 message 属性在其他插槽中不可用：\n\ntemplate\n高级列表组件示例​\n你可能想问什么样的场景才适合用到作用域插槽，这里我们来看一个 <FancyList> 组件的例子。它会渲染一个列表，并同时会封装一些加载远端数据的逻辑、使用数据进行列表渲染、或者是像分页或无限滚动这样更进阶的功能。然而我们希望它能够保留足够的灵活性，将对单个列表元素内容和样式的控制权留给使用它的父组件。我们期望的用法可能是这样的：\n\ntemplate\n在 <FancyList> 之中，我们可以多次渲染 <slot> 并每次都提供不同的数据 (注意我们这里使用了 v-bind 来传递插槽的 props)：\n\ntemplate\n在演练场中尝试一下\n\n无渲染组件​\n上面的 <FancyList> 案例同时封装了可重用的逻辑 (数据获取、分页等) 和视图输出，但也将部分视图输出通过作用域插槽交给了消费者组件来管理。\n\n如果我们将这个概念拓展一下，可以想象的是，一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为无渲染组件。\n\n这里有一个无渲染组件的例子，一个封装了追踪当前鼠标位置逻辑的组件：\n\ntemplate\n在演练场中尝试一下\n\n虽然这个模式很有趣，但大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。之后我们会在组合式函数一章中介绍如何更高效地实现追踪鼠标位置的功能。\n\n尽管如此，作用域插槽在需要同时封装逻辑、组合视图界面时还是很有用，就像上面的 <FancyList> 组件那样。",
        "tags": [
            {
                "word": "vue",
                "weight": 0.2105257079407057
            },
            {
                "word": "组件",
                "weight": 0.2105257079407057
            },
            {
                "word": "javascript",
                "weight": 0.2105257079407057
            },
            {
                "word": "函数",
                "weight": 0.2105257079407057
            },
            {
                "word": "dom",
                "weight": 0.031579433647435415
            },
            {
                "word": "html",
                "weight": 0.031579433647435415
            },
            {
                "word": "标签",
                "weight": 0.031579433647435415
            },
            {
                "word": "对象",
                "weight": 0.031579433647435415
            },
            {
                "word": "列表渲染",
                "weight": 0.031579433647435415
            }
        ]
    },
    {
        "title": "深入 Vue 组件：依赖注入",
        "text": "Prop 逐级透传问题​\n通常情况下，当我们需要从父组件向子组件传递数据时，会使用 props。想象一下这样的结构：有一些多层级嵌套的组件，形成了一颗巨大的组件树，而某个深层的子组件需要一个较远的祖先组件中的部分数据。在这种情况下，如果仅使用 props 则必须将其沿着组件链逐级传递下去，这会非常麻烦：\n\nProp 逐级透传的过程图示\n\n注意，虽然这里的 <Footer> 组件可能根本不关心这些 props，但为了使 <DeepChild> 能访问到它们，仍然需要定义并向下传递。如果组件链路非常长，可能会影响到更多这条路上的组件。这一问题被称为“prop 逐级透传”，显然是我们希望尽量避免的情况。\n\nprovide 和 inject 可以帮助我们解决这一问题。 [1] 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。\n\nProvide/inject 模式\n\nProvide (提供)​\n要为组件后代提供数据，需要使用到 provide 选项：\n\njs\n对于 provide 对象上的每一个属性，后代组件会用其 key 为注入名查找期望注入的值，属性的值就是要提供的数据。\n\n如果我们需要提供依赖当前组件实例的状态 (比如那些由 data() 定义的数据属性)，那么可以以函数形式使用 provide：\n\njs\n然而，请注意这不会使注入保持响应性。我们会在后续小节中讨论如何让注入转变为响应式。\n\n应用层 Provide​\n除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：\n\njs\n在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。\n\nInject (注入)​\n要注入上层组件提供的数据，需使用 inject 选项来声明：\n\njs\n注入会在组件自身的状态之前被解析，因此你可以在 data() 中访问到注入的属性：\n\njs\n完整的 provide + inject 示例\n\n注入别名​\n当以数组形式使用 inject，注入的属性会以同名的 key 暴露到组件实例上。在上面的例子中，提供的属性名为 \"message\"，注入后以 this.message 的形式暴露。访问的本地属性名和注入名是相同的。\n\n如果我们想要用一个不同的本地属性名注入该属性，我们需要在 inject 选项的属性上使用对象的形式：\n\njs\n这里，组件本地化了原注入名 \"message\" 所提供的属性，并将其暴露为 this.localMessage。\n\n注入默认值​\n默认情况下，inject 假设传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。\n\n如果在注入一个值时不要求必须有提供者，那么我们应该声明一个默认值，和 props 类似：\n\njs\n和响应式数据配合使用​\n为保证注入方和供给方之间的响应性链接，我们需要使用 computed() 函数提供一个计算属性：\n\njs\n带有响应性的 provide + inject 完整示例\n\ncomputed() 函数常用于组合式 API 风格的组件中，但它同样还可以用于补充选项式 API 风格的某些用例。你可以通过阅读响应式系统基础和计算属性两个章节了解更多组合式的 API 风格。\n\n临时配置要求\n\n上面的用例需要设置 app.config.unwrapInjectedRef = true 以保证注入会自动解包这个计算属性。这将会在 Vue 3.3 后成为一个默认行为，而我们暂时在此告知此项配置以避免后续升级对代码的破坏性。在 3.3 后就不需要这样做了。\n\n使用 Symbol 作注入名​\n至此，我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。\n\n我们通常推荐在一个单独的文件中导出这些注入名 Symbol：\n\njs\njs\njs\n译者注\n\n[1] 在本章及后续章节中，“提供”将成为对应 Provide 的一个专有概念",
        "tags": [
            {
                "word": "vue",
                "weight": 0.38461394503699525
            },
            {
                "word": "组件",
                "weight": 0.38461394503699525
            },
            {
                "word": "对象",
                "weight": 0.05769302748150241
            },
            {
                "word": "函数",
                "weight": 0.05769302748150241
            },
            {
                "word": "数组",
                "weight": 0.05769302748150241
            },
            {
                "word": "链接",
                "weight": 0.05769302748150241
            }
        ]
    },
    {
        "title": "深入 Vue 组件：异步组件",
        "text": "基本用法​\n在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 defineAsyncComponent 方法来实现此功能：\n\njs\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */)\n  })\n})\n// ... 像使用其他一般组件一样使用 `AsyncComp`\n如你所见，defineAsyncComponent 方法接收一个返回 Promise 的加载函数。这个 Promise 的 resolve 回调方法应该在从服务器获得组件定义时调用。你也可以调用 reject(reason) 表明加载失败。\n\nES 模块动态导入也会返回一个 Promise，所以多数情况下我们会将它和 defineAsyncComponent 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：\n\njs\nimport { defineAsyncComponent } from 'vue'\n\nconst AsyncComp = defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n)\n最后得到的 AsyncComp 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。\n\n与普通组件一样，异步组件可以使用 app.component() 全局注册：\n\njs\napp.component('MyComponent', defineAsyncComponent(() =>\n  import('./components/MyComponent.vue')\n))\n你也可以在局部注册组件时使用 defineAsyncComponent：\n\nvue\n<script>\nimport { defineAsyncComponent } from 'vue'\n\nexport default {\n  components: {\n    AdminPage: defineAsyncComponent(() =>\n      import('./components/AdminPageComponent.vue')\n    )\n  }\n}\n</script>\n\n<template>\n  <AdminPage />\n</template>\n加载与错误状态​\n异步操作不可避免地会涉及到加载和错误状态，因此 defineAsyncComponent() 也支持在高级选项中处理这些状态：\n\njs\nconst AsyncComp = defineAsyncComponent({\n  // 加载函数\n  loader: () => import('./Foo.vue'),\n\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n\n  // 加载失败后展示的组件\n  errorComponent: ErrorComponent,\n  // 如果提供了一个 timeout 时间限制，并超时了\n  // 也会显示这里配置的报错组件，默认值是：Infinity\n  timeout: 3000\n})\n如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。\n\n如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。\n\n搭配 Suspense 使用​\n异步组件可以搭配内置的 <Suspense> 组件一起使用，若想了解 <Suspense> 和异步组件之间交互，请参阅 <Suspense> 章节。",
        "tags": [
            {
                "word": "组件",
                "weight": 0.48648582432442095
            },
            {
                "word": "vue",
                "weight": 0.25675708783778944
            },
            {
                "word": "函数",
                "weight": 0.25675708783778944
            }
        ]
    }
]